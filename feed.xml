<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh-CN"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="http://sidgwick.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="http://sidgwick.github.io/" rel="alternate" type="text/html" hreflang="zh-CN" /><updated>2025-09-10T12:07:14+08:00</updated><id>http://sidgwick.github.io/feed.xml</id><title type="html">挚爱荒原</title><subtitle>宋志刚(Sidgwick)的个人博客, 主要是一些技术记录和分享. 不写博客的技术人员不 是好的技术人员. 工作之余写点小博客, 记录学习中遇到的点点滴滴, 方便自己以后 查看, 也方便和我遇到一样问题的人.
</subtitle><author><name>Zhigang Song</name></author><entry><title type="html">x86 保护模式下栈段描述符的构建</title><link href="http://sidgwick.github.io/2025/07/10/stack-segment.html" rel="alternate" type="text/html" title="x86 保护模式下栈段描述符的构建" /><published>2025-07-10T19:28:04+08:00</published><updated>2025-07-10T19:28:04+08:00</updated><id>http://sidgwick.github.io/2025/07/10/stack-segment</id><content type="html" xml:base="http://sidgwick.github.io/2025/07/10/stack-segment.html"><![CDATA[<p>x86 CPU 在保护模式下需要用段描述符来描述一个段的信息, 对代码段和数据段而言, 描述符的定义比较符合直觉, 但是对栈段来说, 对描述符里面的基地址和段限长解释和普通数据段不同.</p>

<p><img src="https://s3.bmp.ovh/imgs/2025/09/03/3414e96e346f282a.png" alt="段描述符组成" /></p>

<p>这里我们要讨论的问题是, 如果申请到一段地址范围为 $[LA, HA]$ 的地址空间, 如何构造一个栈段描述符, 刚好使得栈在这段范围之内?</p>

<!--more-->

<p>首先我们要构造的是一个栈段描述符, 考虑稍微复杂一点的 4Kb 粒度的情况, 我们令 G=1, DB=1, AVL=0, P=1, DPL=00, TYPE=0110.
接下来问题简化为求基地址和段限长, 只要算出这两个字段, 就可以顺利构造出栈段描述符.</p>

<p><img src="https://s3.bmp.ovh/imgs/2025/09/09/a5b4104d7b0c8e94.png" alt="申请到的内存空间示意图" /></p>

<p>设描述符中的基地址为$BA$, 段限长(<strong>Effect Limit</strong>)为 $EL$, 有效偏移(<strong>Valid Offset</strong>)为 $VO$.</p>

<p>根据 <a href="https://flint.cs.yale.edu/cs422/doc/24547212.pdf">Intel Architecture Software Developer’s Manual Volume 3:System Programming</a> 第 4.3 节的说明(请注意黄色的字):</p>

<p><img src="https://s3.bmp.ovh/imgs/2025/09/09/768e5686afec622f.png" alt="第 4.3 节" /></p>

<p>这段文字告诉我们, 实际上的栈段合法范围其实要按照下面式子计算(下标 $x$ 的意思是, 算出来的地址值已经超过了地址线的宽度, 这时候实际地址其实是需要按照地址线宽度做 <code class="language-plaintext highlighter-rouge">&amp;</code> 操作求出):</p>

\[HA_x = BA + \mathtt{0xFF...FF} \\
LA_x = BA + EL + 1\]

<p>于是, 可以知道 $VO$ 的范围:</p>

\[VO \in \left[ (EL+1), \mathtt{0xFF...FF} \right]\]

<p>因为我们已经有 $LA$, $HA$, 可知栈空间大小为 $ SIZE = HA - LA + 1 $</p>

<p>而且</p>

\[\begin{equation}
    SIZE = HA_x - LA_x + 1
\end{equation}\]

<h2 id="颗粒度为字节的情况g0">颗粒度为字节的情况(G=0)</h2>

<p>先考虑 G=0 的情况, 稍微简单一些.</p>

<p>因为基地址加上偏移值才是实际的物理地址, 那么可以得出:</p>

\[\begin{equation}
    (EL + 1) + BA = LA_{x}
\end{equation}\]

\[\begin{equation}
    0xFFFFFFFF + BA = HA_{x}
\end{equation}\]

<p>联立 <strong>(2)</strong>, <strong>(3)</strong>, <strong>(4)</strong> 式得到:</p>

\[\begin{equation}
    EL = \mathtt{0xFFFFFFFF} - SIZE
\end{equation}\]

<p>也就是说, 知道了栈空间的大小 $SIZE$, 就能算出 $EL$.</p>

<p>把 <strong>(4)</strong> 式代入 <strong>(2)</strong> 式, 有:</p>

\[\begin{align*}
    \mathtt{0xFFFFFFFF} - SIZE + 1 + BA &amp;= LA_{x} \\
                                 &amp;= LA + (\mathtt{0xFFFFFFFF} + 1)
\end{align*}\]

<p>可以得到:</p>

\[\begin{equation}
    BA = SIZE + LA
\end{equation}\]

<p>也就是说, 段描述符中的基地址 $BA$ 等于栈空间的最低端地址 $LA$ 加上栈空间的大小.</p>

<p>通过上面的推导，我们得出 <strong>(4)</strong> 和 <strong>(5)</strong> 这 2 个公式, 可以用来计算 $EL$, $BA$.</p>

<p>当 G=0 的时候, EL 就是我们要填充到描述符里面的段限长 limit, 接下来讨论 G=1 的情况.</p>

<h2 id="颗粒度为-4kb-的情况g1">颗粒度为 4Kb 的情况(G=1)</h2>

<p>当 G=1 的时候, EL 和段限长 limit 的关系为:</p>

\[\begin{equation}
\mathtt{limit} \times 4K + \mathtt{0xFFF} = EL
\end{equation}\]

<p>因为 G=1, 栈空间大小一定是 4 的整数倍, 因此我们可以假设</p>

\[\begin{equation}
SIZE = N \times 4K
\end{equation}\]

<p>联立 <strong>(4)</strong>, <strong>(6)</strong>, <strong>(7)</strong> 有:</p>

\[\begin{align*}
    \mathtt{limit} &amp;= \frac{\mathtt{0xFFFFFFFF} - N \times 4K - \mathtt{0xFFF}}{4K} \\
                   &amp;= 0xFFFFF - N
\end{align*}\]

<p>下面说一下 ESP 的初值, 因为在加载栈段描述符之后, SS 的值就是 $BA$, 而且栈是从高空间向低空间增长, 因此预期是 ESP 在最开始的那次 <code class="language-plaintext highlighter-rouge">push</code> 操作, 应该吧数据放在 $[HA-4, HA]$ 这几个内存单元里面, 因为 $BA + \mathtt{0xFFFFFFFF}$ = $HA_x$, 因此, ESP 在第一次操作的时候值应该是 $\mathtt{0xFFFFFFFC}$. 又因为 <code class="language-plaintext highlighter-rouge">push</code> 操作是先减 ESP 再操作, 因此最开始的 ESP 值应该是 $\mathtt{0x00000000}$.</p>]]></content><author><name>Zhigang Song</name></author><category term="x86" /><category term="assembly" /><summary type="html"><![CDATA[x86 CPU 在保护模式下需要用段描述符来描述一个段的信息, 对代码段和数据段而言, 描述符的定义比较符合直觉, 但是对栈段来说, 对描述符里面的基地址和段限长解释和普通数据段不同. 这里我们要讨论的问题是, 如果申请到一段地址范围为 $[LA, HA]$ 的地址空间, 如何构造一个栈段描述符, 刚好使得栈在这段范围之内?]]></summary></entry><entry><title type="html">PID控制原理与增量式PID算法</title><link href="http://sidgwick.github.io/2024/10/12/pid-algorithm.html" rel="alternate" type="text/html" title="PID控制原理与增量式PID算法" /><published>2024-10-12T19:32:41+08:00</published><updated>2024-10-12T19:32:41+08:00</updated><id>http://sidgwick.github.io/2024/10/12/pid-algorithm</id><content type="html" xml:base="http://sidgwick.github.io/2024/10/12/pid-algorithm.html"><![CDATA[<p>本文可运行的 <a href="http://www.baidu.com">Jupyter Notebook 链接</a></p>

<!--more-->

<h1 id="pid控制原理与增量式pid算法">PID控制原理与增量式PID算法</h1>

<blockquote>
  <p>本小节在理论上讲解 PID 控制原理, 先引出模拟 PID 控制公式, 然后离散化处理得到数字 PID 控制公式, 推导出位置式 PID 控制公式, 再进一步推导出增量式 PID 控制公式.</p>
</blockquote>

<p>将偏差的比例(Proportion), 积分(Integral)和微分(Differential)通过线性组合构成控制量, 用这一控制量对被控对象进行控制, 这样的控制器称 PID 控制器.</p>

<h2 id="模拟-pid-控制">模拟 PID 控制</h2>

<p>在模拟控制系统中, 控制器最常用的控制规律是PID控制. 为了说明控制器的工作原理, 先看一个例子. 下图所示是一个小功率直流电机的调速框图:</p>

<p><img src="https://c.miaowlabs.com/img/2019-01-03_210504.png" alt="" /></p>

<p>上图中, 给定转速 $n_0(t)$ 与实际转速 $n(t)$ 进行比较, 其差值 $e(t) = n_0(t) - n(t)$, 经过 PID 控制器调整后输出电压控制信号 $u(t)$, $u(t)$ 经过功率放大后, 驱动直流电动机改变其转速.</p>

<blockquote>
  <p>强化:</p>

  <ul>
    <li>PID 控制器能输出的是电压控制信号</li>
  </ul>
</blockquote>

<p>抽象化的模拟PID控制系统原理框图, 如下图所示, 该系统由模拟PID控制器和被控对象组成:</p>

<p><img src="https://c.miaowlabs.com/img/2019-01-03_210531.png" alt="" /></p>

<p>图中 $r(t)$ 是给定预期输出值, $y(t)$ 是系统的实际输出值, 给定值与实际输出值构成控制偏差:</p>

\[e(t) = r(t) - y(t)
\tag{式1-1}\]

<p>$e(t)$ 作为 PID 控制的输入, $u(t)$ 作为 PID 控制器的输出和被控对象的输入. 所以模拟 PID 控制器的控制规律为:</p>

\[u(t) = K_p e(t) + K_i \int_{0}^{t} e(\tau)d\tau + K_d \frac{de(t)}{dt}
\tag{式1-2}\]

<p>其中</p>

<ul>
  <li>$K_p$ 是比例增益，是调适参数</li>
  <li>$K_i$ 是积分增益，也是调适参数</li>
  <li>$K_d$ 是微分增益，也是调适参数</li>
  <li>$e$ 是误差, 值等于 设定值(SP) - 回授值(PV)</li>
  <li>$t$ 是目前时间</li>
  <li>$\tau$ 积分变数，数值从0到目前时间</li>
</ul>

<p>用更专业的话来讲, PID控制器可以视为是频域系统的滤波器器. 在计算控制器最终是否会达到稳定结果时, 此性质很有用. 如果数值挑选不当, 控制系统的输入值会反复振荡, 这导致系统可能永远无法达到预设值.</p>

<p>PID 控制器的一般转移函数是:</p>

\[H(s) = \frac{K_d s^2 + K_p s + K_i}{s+C}\]

<p>其中 $C$ 是一个取决于系统带宽的常数.</p>

<h2 id="数字pid控制">数字PID控制</h2>

<p>由于计算机的出现, 计算机进入了控制领域. 人们将模拟 PID 控制规律引入到计算机中来, 对 (式1-2) 的 PID 控制规律进行适当的变换, 就可以用软件实现 PID 控制, 即数字 PID 控制.</p>

<p>数字式 PID 控制算法可以分为位置式 PID 和增量式 PID 控制算法.</p>

<h3 id="位置式pid算法">位置式PID算法</h3>

<p>由于计算机控制是一种采样控制, 它只能根据采样时刻的偏差计算控制量, 而不能像模拟控制那样连续输出控制量进行连续控制. 由于这一特点, (式1-2)中的积分项和微分项不能直接使用, 必须进行离散化处理.</p>

<p>离散化处理的方法为: 以 $T$ 作为采样周期, $k$ 作为采样序号, 则离散采样时间 $kT$ 对应着连续时间 $t$, 用矩形法数值积分近似代替积分, 用一阶后向差分近似代替微分, 可作如下近似变换:</p>

\[\begin{align*}
    t \approx &amp; k T \quad (k = 0, 1, 2, \dots) \\ \\
    \int_{0}^{t} e(t) dt \approx &amp; T \sum_{j=0}^{k} e(jT) = T \sum_{j=0}{k} e_j \\ \\
    \frac{de(t)}{dt} \approx &amp; \frac{e(kT) - e((k-1)T)}{T} = \frac{e_k - e_{k-1}}{T} \\
\end{align*}\]

<p>上式中为了表达的方便将类似于 $e(kT)$ 简化成 $e_k$ 等.</p>

<p>将 (式2-1) 代入 (式1-2), 就可以得到离散的 PID 表达式为:</p>

\[u_k = K_p e_k + K_i \sum_{j=0}^{k} e_j + K_d(e_k - e_{k-1})
    \tag{式2-3}\]

<p>其中:</p>

<ul>
  <li>$k$ 为采样序号, $k = 0,1,2,\dots$</li>
  <li>$u_k$ 为第 $k$ 次采样时刻的计算机输出值</li>
  <li>$e_k$ 为第 $k$ 次采样时刻输入的偏差值</li>
  <li>$e_k-1$ 为第 $k-1$ 次采样时刻输入的偏差值</li>
  <li>$K_i$ 为积分系数, $K_i = kp* \frac{T}{T_i}$</li>
  <li>$K_d$ 为微分系数, $K_d = K_p * \frac{Td}{T}$</li>
</ul>

<blockquote>
  <p>注意</p>

  <p>(式2-3) 和 (式1-2) 里面的系数不完全等价, 这里只是在描述推导数字式 PID 的公式形式.</p>
</blockquote>

<p>如果采样周期足够小, 则 (式2-3) 的近似计算可以获得足够精确的结果, 离散控制过程与连续过程十分接近.</p>

<p>(式2-3) 表示的控制算法式直接按 (式1-2) 所给出的 PID 控制规律定义进行计算的, 所以它给出了全部控制量的大小, 因此被称为全量式或位置式 PID 控制算法.</p>

<blockquote>
  <p>这句话在说啥???</p>
</blockquote>

<p>这种算法的缺点是: 由于全量输出, 所以每次输出均与过去状态有关, 计算时要对 $e_k$ 进行累加, 工作量大. 并且, 因为计算机输出的对应的是执行机构的实际位置, 如果计算机出现故障, 输出将大幅度变化, 会引起执行机构的大幅度变化, 有可能因此造成严重的生产事故, 这在实际生产际中是不允许的.</p>

<h3 id="增量式pid算法">增量式PID算法</h3>

<p>所谓增量式 PID 是指数字控制器的输出只是控制量的增量 $\Delta{u_k}$, 当执行机构需要的控制量是增量, 而不是位置量的绝对数值时, 可以使用增量式 PID 控制算法进行控制.</p>

<p>增量式 PID 控制算法可以通过 (式2-3) 推导出:</p>

\[\begin{align*}
    \Delta{u_k} = &amp; u_k - u_{k-1} \\ \\
                = &amp; \left ( K_p e_k + K_i \sum_{j=0}^{k} e_j + K_d(e_k - e_{k-1}) \right ) -
                    \left ( K_p e_{k-1} + K_i \sum_{j=0}^{{k-1}} e_j + K_d(e_{k-1} - e_{k-2}) \right ) \\ \\
                = &amp; K_p (e_k - e_{k-1}) + K_i e_k + K_d(e_k - 2 e_{k-1} + e_{k-2}) \\ \\
                = &amp; (K_p + K_i + K_d) e_k - (K_p + 2K_d) e_{k-1} + K_d e_{k-2} \\ \\
                = &amp; A e_k + B e_{k-1} + C e_{k-2}
\end{align*}

\tag{式 2-5}\]

<p>由 (式2-5) 可以看出, 如果计算机控制系统采用恒定的采样周期 $T$, 一旦确定 A, B, C, 只要使用前后三次测量的偏差值, 就可以由 (式2-5) 求出控制量.</p>

<p>增量式 PID 控制算法与位置式 PID 算法 (式2-2) 相比, 计算量小的多, 因此在实际中得到广泛的应用.</p>

<p>而位置式 PID 控制算法也可以通过增量式控制算法推出送推计算公式:</p>

\[u_k = u_{k - 1} + \Delta{u_k}
\tag{式2-6}\]

<p>(式2-6) 就是目前在计算机控制中广泛应用的数字递推PID控制算法</p>

<h2 id="采样周期的选择">采样周期的选择</h2>

<p>香农(Shannon)采样定律: 为不失真地复现信号的变化, 采样频率至少应大于或等于连续信号最高频率分量的二倍. 根据采样定律可以确定采样周期的上限值, 实际采采样周期的选择还要受到多方面因素的影响, 不同的系统采样周期应根据具体情况来选择.</p>

<p>采样周期的选择, 通常按照过程特性与干扰大小适当来选取采洋周期: 即对于响应快(如流量/压力), 波动大, 易受干扰的过程, 应选取较短的采样周期; 反之, 当过程响应慢(如温度, 成份), 滞后大时可选取较长的采样周期.</p>

<p>采样周期的选取应与 PID 参数的整定进行综合考虑, 采样周期应远小于过程的扰动信号的周期, 在执行器的响应速度比较慢时, 过小的采样周期将失去意义, 因此可适当运选大一点. 在计算机运算速度允许的条件下, 采样周期短, 则控制品质好. 当过程的纯滞后时间较长时, 一般选取采样周期为纯滞后时间的 1/4 ~ 1/8</p>]]></content><author><name>Zhigang Song</name></author><category term="pid" /><category term="hardware" /><category term="algorithm" /><summary type="html"><![CDATA[本文可运行的 Jupyter Notebook 链接]]></summary></entry><entry><title type="html">机器学习基石 - 作业 2</title><link href="http://sidgwick.github.io/2024/02/27/Machine-Learning-Mathematical-Foundations-hw2.html" rel="alternate" type="text/html" title="机器学习基石 - 作业 2" /><published>2024-02-27T19:14:41+08:00</published><updated>2024-02-27T19:14:41+08:00</updated><id>http://sidgwick.github.io/2024/02/27/Machine-Learning-Mathematical-Foundations-hw2</id><content type="html" xml:base="http://sidgwick.github.io/2024/02/27/Machine-Learning-Mathematical-Foundations-hw2.html"><![CDATA[<p>本文可运行的 <a href="http://www.baidu.com">Jupyter Notebook 链接</a></p>

<!--more-->

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="n">math</span>
<span class="kn">from</span> <span class="n">functools</span> <span class="kn">import</span> <span class="o">*</span>
</code></pre></div></div>

<p><img src="./images/q16.png" alt="Coursera Question 16" /></p>

<p>在课堂上, 我们讲授了一维数据的’正负射线’(简单来说就是一维感知器)的学习模型. 该模型包含以下形式的假设:</p>

\[h_{s,\theta}(x) = s \cdot{} sign(x - \theta)\]

<p>该模型通常被称为’决策树桩’模型, 是最简单的学习模型之一. 如课堂所示, 对于一维数据, 决策树桩模型的 VC 维为 2.</p>

<p>事实上, 决策树桩模型是我们可以​通过枚举所有可能的阈值来有效地轻松最小化 $E_{in}$ 的少数模型之一. 特别地, 对于 $N$ 个例子, 最多有 $ 2N $ 个 dichotomy(参见第 5 课幻灯片的第 22 页), 因此最多有 $2N$ 个不同 $E_{in}$ 值. 然后我们可以轻松地选择使得 $E_{in}$ 最小的 dichotomy, 其中可以通过在最小的 $E_{in}$ 中随机选择来消除平局(原文: We can then easily choose the dichotomy that leads to the lowest $E_{in}$, where ties can be broken by randomly choosing among the lowest $E_{in}$ ones). 所选的 dichotomy 表示某些点($\theta$ 范围)和 $s$ 的组合(这里是说 $\theta$ 和 $s$ 的组合确定了一个 dichotomy, 对这个 dichotomy 来说, $\theta$ 的取值本身是一个范围, 在这个范围内, 给定的样本都可以形成同一个 dichotomy), 通常将该范围的中值选作实现 dichotomy 的 $\theta$.</p>

<p>在本题中, 我们将实现这样的算法, 并在人工数据集上运行程序.</p>

<p>首先, 通过以下过程生成一维数据:</p>

<ol>
  <li>在 $[-1,1]$ 中通过均匀分布生成 $x$</li>
  <li>通过 $f(x) = \tilde{s}(x) + noise$ 生成 $y$, 其中 $\tilde{s}(x) = sign(x)$ 并且噪声以 20% 的概率翻转结果.</li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">h</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">theta</span>
    <span class="k">return</span> <span class="n">s</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">example_data</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">
    f(x) = sign(x), flips result with 20% probability
    </span><span class="sh">"""</span>

    <span class="k">def</span> <span class="nf">sign</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="mi">1</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">data</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">flip</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">rand</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.2</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">x</span>

        <span class="k">return</span> <span class="n">x</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">uniform</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="nf">flip</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nf">sign</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span>

    <span class="n">res</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="nf">zip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
    <span class="c1"># np.random.shuffle(res)
</span>
    <span class="k">return</span> <span class="n">res</span>
</code></pre></div></div>

<h2 id="question-16">Question 16</h2>

<p>对于任何决策树桩 $h_{s,\theta}$, $\theta \in [-1,1]$, 将 $E_{out}(h_{s,\theta})$ 表示为 $\theta$ 和 $s$ 的函数.</p>

<p><strong>解:</strong></p>

<p>考虑作业 2 的第一题, 提到有噪声版的目标函数 $f$ 用下面的形式给出:</p>

\[P(y \mid x) = \begin{cases}
      \lambda &amp; y = f(x)\\
      1 - \lambda &amp; \text{otherwise}
    \end{cases}\]

<p>假设函数 $h$ 犯错误的概率是 $ \mu $, 那么错误概率可以写成:</p>

\[E_{out} = \lambda \mu + (1-\lambda)(1-\mu)\]

<blockquote>
  <p>$E_{in}, E_{out}$ 可以用这种概率形式表示吗?</p>

  <p>在未来课程中, 逻辑斯蒂回归使用的交叉熵错误, 看上去是一个概率形式的表达.</p>
</blockquote>

<p>题目中, 已经告诉我们 $\lambda = 1-20\% = 0.8$, 下面试着计算 $\mu$, 情况比较复杂, 对 $s$ 分类讨论(决策树桩的 $s \in {-1, +1} $):</p>

<ol>
  <li>$s = +1$, $\theta &gt; 0$ 时, $x \in [-1, 1]$ 的点里面, $x \in [0, \theta]$ 部分是分类错误(和无噪声的 $f$ 不一样)的, 因此有 $\mu = \frac{\theta}{2}$</li>
  <li>$s = +1$, $\theta &lt; 0$ 时, 参考 1 的分析, 有 $\mu = \frac{\lvert \theta \rvert}{2}$</li>
  <li>$s = -1$, $\theta &gt; 0$ 时, 参考 1 的分析, 有 $\mu = 1 - \frac{\theta}{2}$</li>
  <li>$s = -1$, $\theta &lt; 0$ 时, 参考 1 的分析, 有 $\mu = 1 - \frac{\lvert \theta \rvert}{2}$</li>
</ol>

<p>把上面四种情况写在一起(注意这不是对概率在求和, 只是将上面四种情况用一个式子表达了出来而已):</p>

\[\begin{align*}
\mu &amp;= \frac{1+s}{2} \times \frac{\lvert \theta \rvert}{2} + \frac{1-s}{2} \times (1 - \frac{\lvert \theta \rvert}{2}) \\
&amp;= \frac{1}{2}(s \lvert \theta \rvert - s + 1)
\end{align*}\]

<p>$E_{out}$ 里面代入 $\lambda$ 和 $\mu$, 可以得到 $E_{out} = 0.5 + 0.3s(\lvert \theta \rvert - 1)$</p>

<p><img src="./images/q17.jpg" alt="Coursera Question 17" /></p>

<h2 id="question-17">Question 17</h2>

<p>按照上述过程生成大小为 20 的数据集, 并在数据集上运行一维决策树桩算法. 记录 $E_{in}$ 并使用上述公式计算 $E_{out}$, 重复该实验(包括数据生成, 运行决策树桩算法以及计算 $E_{in}$ 和 $E_{out}$) 5000 次. $E_{in}$ 的平均值是多少?</p>

<p><strong>解:</strong></p>

<p>按照题目的说法, 我们要暴力遍历所有的 dichotomy, 因此先准备好能决定 dichotomy 的 $(\theta, s)$ 集合. 如果 \(x \in \{ x_1, x_2, ... x_{20} \mid x_1 &lt; x_2 &lt; ... &lt; x_{20} \}\), 那么 $\theta$ 可以取的值有(使用每个 dichotomy $\theta$ 范围的中值) $ \frac{-1 + x_1}{2}, \frac{x_1 + x_2}{2}, …, \frac{x_{19} + x_{20}}{2}, \frac{x_{20} + 1}{2} $, 共计 21 个点.</p>

<p>至于 $s$, 它仅可以取 ${-1, +1}$.</p>

<blockquote>
  <p>出于计算后面的 19/20 题通用考虑, 下面的代码里面对第一个和最后一个 $\theta$ 的处理, 不是用的 $-1$ 和 $+1$ 边界, 而是用的 $ x_0 - 1$ 和 $ x_{20} + 1 $.</p>
</blockquote>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">get_theta_list</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">xs</span> <span class="o">=</span> <span class="nf">sorted</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">data</span><span class="p">])</span>

    <span class="n">prev</span> <span class="o">=</span> <span class="n">xs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xs</span><span class="p">:</span>
        <span class="n">result</span><span class="p">.</span><span class="nf">append</span><span class="p">((</span><span class="n">prev</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="n">x</span>

    <span class="n">result</span><span class="p">.</span><span class="nf">append</span><span class="p">((</span><span class="n">prev</span> <span class="o">+</span> <span class="n">prev</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">result</span>

<span class="k">def</span> <span class="nf">get_dichotomy_theta_and_s</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">theta_list</span> <span class="o">=</span> <span class="nf">get_theta_list</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">theta</span> <span class="ow">in</span> <span class="n">theta_list</span><span class="p">:</span>
        <span class="n">result</span><span class="p">.</span><span class="nf">append</span><span class="p">((</span><span class="n">theta</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">result</span><span class="p">.</span><span class="nf">append</span><span class="p">((</span><span class="n">theta</span><span class="p">,</span> <span class="o">+</span><span class="mi">1</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">result</span>
</code></pre></div></div>

<p>有了 $(\theta, s)$ 的集合之后, 所要做的事情就是遍历这个集合, 并计算在样本点上的 $E_{in}$, 然后用上面的公式可以算 $E_{out}$ 出来.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">decision_stump</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="n">dichotomy_list</span> <span class="o">=</span> <span class="nf">get_dichotomy_theta_and_s</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="n">best</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">best_in</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">inf</span>
    <span class="n">best_out</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">inf</span>
    
    <span class="k">for</span> <span class="n">theta</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">dichotomy_list</span><span class="p">:</span>
        <span class="n">_h</span> <span class="o">=</span> <span class="nf">partial</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
        
        <span class="c1"># 代入数据运算
</span>        <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
            <span class="n">err</span> <span class="o">+=</span> <span class="nf">_h</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="n">y</span>

        <span class="k">if</span> <span class="n">err</span> <span class="o">&lt;</span> <span class="n">best_in</span><span class="p">:</span>
            <span class="n">best_in</span> <span class="o">=</span> <span class="n">err</span>
            <span class="n">best</span> <span class="o">=</span> <span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>

        <span class="n">err_out</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">+</span> <span class="mf">0.3</span><span class="o">*</span><span class="n">s</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">abs</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">err_out</span> <span class="o">&lt;</span> <span class="n">best_out</span><span class="p">:</span>
            <span class="n">best_out</span> <span class="o">=</span> <span class="n">err_out</span>
            <span class="c1"># print(s, theta, err_out)
</span>
    <span class="k">return</span> <span class="n">best_in</span> <span class="o">/</span> <span class="nf">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">best_out</span><span class="p">,</span> <span class="n">best</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">loops</span> <span class="o">=</span> <span class="mi">5000</span>

<span class="n">err_in</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">err_out</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">loops</span><span class="p">):</span>
    <span class="n">data</span> <span class="o">=</span> <span class="nf">example_data</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
    <span class="n">e_in</span><span class="p">,</span> <span class="n">e_out</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="nf">decision_stump</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    
    <span class="n">err_in</span> <span class="o">+=</span> <span class="n">e_in</span>
    <span class="n">err_out</span> <span class="o">+=</span> <span class="n">e_out</span>

<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">err_in</span><span class="sh">"</span><span class="p">,</span> <span class="n">err_in</span> <span class="o">/</span> <span class="n">loops</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">err_out</span><span class="sh">"</span><span class="p">,</span> <span class="n">err_out</span> <span class="o">/</span> <span class="n">loops</span><span class="p">)</span>
</code></pre></div></div>

<p>代码输出:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>err_in 0.16993999999999992
err_out 0.21064865779191114
</code></pre></div></div>

<p><img src="./images/q18.png" alt="Coursera Question 18" /></p>

<h2 id="question-18">Question 18</h2>

<p><strong>解:</strong></p>

<p>参考 Question 17 里面关于 $E_{out}$ 的计算.</p>

<p><strong>疑问❓❓❓</strong></p>

<p>我最开始的更新错误部分的写法实际上是:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="n">err</span> <span class="o">&lt;</span> <span class="n">best_in</span><span class="p">:</span>
    <span class="n">best_in</span> <span class="o">=</span> <span class="n">err</span>
    <span class="n">best_out</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">+</span> <span class="mf">0.3</span><span class="o">*</span><span class="n">s</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">abs</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<p>也就是只有在遇到更好的 err_in 的时候, 才用它的 $s, \theta$ 来更新一下 <code class="language-plaintext highlighter-rouge">best_out</code>, 但是这样算出来 $E_{out}$ 均值达到了 $0.7$</p>

<blockquote>
  <p><strong>!!!</strong></p>

  <p>这里为什么要在无论何种场景下都要更新 $E_{out}$ 呢?</p>
</blockquote>

<p><img src="./images/q19.png" alt="Coursera Question 19" /></p>

<h2 id="question-19">Question 19</h2>

<p>决策树桩也适用于多维数据. 特别地, 现在每个决策树桩处理一个特定的维度 $i$, 如下:</p>

\[h_{s,i,\theta}(x) = s \cdot{} sign(x_i - \theta)\]

<p>对多维数据实现以下决策树桩算法:</p>

<ol>
  <li>对于每个维度 $i = 1, 2, … , d$, 使用你刚刚实现的一维决策桩算法找到最佳决策桩 $h_{s,i, \theta}$</li>
  <li>返回以 $E_{in}$ 而言 ‘最佳中的最佳’ 决策桩. 如果出现平局, 请从 $E_{in}$ 最小的桩中随机选择一个(原文: return the “best of best” decision stump in terms of $E_{in}$. If there is a tie, please randomly choose among the lowest-$E_{in}$ ones, 原文读的有点稀里糊涂, 这意思是不是说计算好 N 个维度之后, 返回 N 个维度最小的 $E_{in}$ 里面的那个最小的? 从网上别人的代码看, 好像是要这么干)</li>
</ol>

<p>训练数据 $\mathcal{D}_{train}$ 可在以下位置获得: <a href="https://www.csie.ntu.edu.tw/~htlin/mooc/datasets/mlfound_math/hw2_train.dat">https://www.csie.ntu.edu.tw/~htlin/mooc/datasets/mlfound_math/hw2_train.dat</a></p>

<p>测试数据 $\mathcal{D}_{test}$ 可在以下位置获得: <a href="https://www.csie.ntu.edu.tw/~htlin/mooc/datasets/mlfound_math/hw2_test.dat">https://www.csie.ntu.edu.tw/~htlin/mooc/datasets/mlfound_math/hw2_test.dat</a></p>

<p>对 \(\mathcal{D}_{train}\) 运行该算法, 报告您的程序返回的最佳决策桩的 \(E_{in}\)</p>

<p><strong>解:</strong></p>

<p>读取并处理原始数据, 然后送到 Question 17 实现的算法里面计算即可.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">read_data</span><span class="p">(</span><span class="nb">file</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">fh</span> <span class="o">=</span> <span class="nf">open</span><span class="p">(</span><span class="nb">file</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">fh</span><span class="p">.</span><span class="nf">readlines</span><span class="p">():</span>
        <span class="n">parts</span> <span class="o">=</span> <span class="n">line</span><span class="p">.</span><span class="nf">strip</span><span class="p">().</span><span class="nf">split</span><span class="p">(</span><span class="sh">"</span><span class="s"> </span><span class="sh">"</span><span class="p">)</span>

        <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="nf">float</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">parts</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">result</span><span class="p">.</span><span class="nf">append</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">result</span>

<span class="k">def</span> <span class="nf">train</span><span class="p">(</span><span class="n">_data</span><span class="p">):</span>
    <span class="n">dim</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">_data</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>

    <span class="n">params</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">best_in</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">inf</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">[(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">_data</span><span class="p">]</span>
        <span class="n">err_in</span><span class="p">,</span> <span class="n">err_out</span><span class="p">,</span> <span class="n">best</span> <span class="o">=</span> <span class="nf">decision_stump</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        
        <span class="c1"># 记一下这维度上表现最好的 theta 和 s, 以后预测可以用
</span>        <span class="n">params</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">best</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">err_in</span> <span class="o">&lt;</span> <span class="n">best_in</span><span class="p">:</span>
            <span class="n">best_in</span> <span class="o">=</span> <span class="n">err_in</span>

    <span class="k">return</span> <span class="n">best_in</span><span class="p">,</span> <span class="n">params</span>

<span class="n">train_dat</span> <span class="o">=</span> <span class="nf">read_data</span><span class="p">(</span><span class="sh">"</span><span class="s">hw2_train.dat</span><span class="sh">"</span><span class="p">)</span>
<span class="n">err_in</span><span class="p">,</span> <span class="n">params</span> <span class="o">=</span> <span class="nf">train</span><span class="p">(</span><span class="n">train_dat</span><span class="p">)</span>

<span class="nf">print</span><span class="p">(</span><span class="n">err_in</span><span class="p">)</span>
</code></pre></div></div>

<p>代码输出:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0.25
</code></pre></div></div>

<p><img src="./images/q20.png" alt="Coursera Question 20" /></p>

<h2 id="question-20">Question 20</h2>

<p>用第 19 题求得的 params, 在 $\mathcal{D}_{test}$ 上面执行预测, 并收集每个维度上的错误情况, 最后报告一个最小的错误.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>
    <span class="n">_data</span> <span class="o">=</span> <span class="nf">read_data</span><span class="p">(</span><span class="sh">"</span><span class="s">hw2_test.dat</span><span class="sh">"</span><span class="p">)</span>

    <span class="n">err_out</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>
        <span class="n">_h</span> <span class="o">=</span> <span class="nf">partial</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
        
        <span class="c1"># 预测测试集数据
</span>        <span class="n">data</span> <span class="o">=</span> <span class="p">[(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">_data</span><span class="p">]</span>

        <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
            <span class="n">err</span> <span class="o">+=</span> <span class="nf">_h</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="n">y</span>

        <span class="n">err_out</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">(</span><span class="n">err_out</span><span class="p">)</span> <span class="o">/</span> <span class="nf">len</span><span class="p">(</span><span class="n">_data</span><span class="p">)</span>

<span class="n">res</span> <span class="o">=</span> <span class="nf">test</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
<span class="n">np</span><span class="p">.</span><span class="nf">min</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
</code></pre></div></div>

<p>代码输出:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0.355
</code></pre></div></div>]]></content><author><name>Zhigang Song</name></author><category term="ai" /><category term="ntu" /><category term="machine-learning" /><category term="mathematical-foundations" /><summary type="html"><![CDATA[本文可运行的 Jupyter Notebook 链接]]></summary></entry><entry><title type="html">使用 Vue 创建 Web Component</title><link href="http://sidgwick.github.io/2024/01/25/vue-web-component.html" rel="alternate" type="text/html" title="使用 Vue 创建 Web Component" /><published>2024-01-25T03:00:00+08:00</published><updated>2024-01-25T03:00:00+08:00</updated><id>http://sidgwick.github.io/2024/01/25/vue-web-component</id><content type="html" xml:base="http://sidgwick.github.io/2024/01/25/vue-web-component.html"><![CDATA[<h1 id="准备">准备</h1>

<p>安装 vue 命令行工具:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> yarn global add @vue/cli
</code></pre></div></div>

<p>生成一个空白仓库:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> vue create json-viewer
</code></pre></div></div>

<p>可以使用的选项如下(参考, 根据自己的需要调整):</p>

<!--more-->

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Vue CLI v5.0.8
? Please pick a preset: Manually select features
? Check the features needed for your project: Babel, TS, CSS Pre-processors, Linter
? Choose a version of Vue.js that you want to start the project with 2.x
? Use class-style component syntax? No
? Use Babel alongside TypeScript (required for modern mode, auto-detected polyfills, transpiling JSX)? No
? Pick a CSS pre-processor (PostCSS, Autoprefixer and CSS Modules are supported by default): Sass/SCSS (with dart-sass)
? Pick a linter / formatter config: Prettier
? Pick additional lint features: Lint on save
? Where do you prefer placing config for Babel, ESLint, etc.? In dedicated config files
? Save this as a preset for future projects? No
</code></pre></div></div>

<h1 id="开发">开发</h1>

<h2 id="功能开发">功能开发</h2>

<p>功能开发可以像普通的 vue 应用一样进行.</p>

<p>删除 <code class="language-plaintext highlighter-rouge">HelloWorld</code> 组件, 并创建一个叫做 <code class="language-plaintext highlighter-rouge">TwoCounter</code> 的组件, 这个组件引用另一个叫做 <code class="language-plaintext highlighter-rouge">BasicCounter</code> 的组件.</p>

<p>两个文件内容分别如下:</p>

<p>BasicCounter.vue</p>

<div class="language-vue highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;</span><span class="k">template</span><span class="nt">&gt;</span>
  <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"basic-counter"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;h1&gt;</span>Counter - <span class="si">{{</span> <span class="nx">index</span> <span class="si">}}</span><span class="nt">&lt;/h1&gt;</span>
    <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"counter"</span><span class="nt">&gt;</span>
      <span class="nt">&lt;p&gt;</span>Cuttent Value is <span class="si">{{</span> <span class="nx">counter</span> <span class="si">}}</span><span class="nt">&lt;/p&gt;</span>
      <span class="nt">&lt;button</span> <span class="err">@</span><span class="na">click=</span><span class="s">"increment"</span><span class="nt">&gt;</span>Increment<span class="nt">&lt;/button&gt;</span>
      <span class="nt">&lt;button</span> <span class="err">@</span><span class="na">click=</span><span class="s">"decrement"</span><span class="nt">&gt;</span>Decrement<span class="nt">&lt;/button&gt;</span>
    <span class="nt">&lt;/div&gt;</span>
  <span class="nt">&lt;/div&gt;</span>
<span class="nt">&lt;/</span><span class="k">template</span><span class="nt">&gt;</span>

<span class="nt">&lt;</span><span class="k">script</span> <span class="na">lang=</span><span class="s">"ts"</span><span class="nt">&gt;</span>
<span class="k">import</span> <span class="nx">Vue</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">vue</span><span class="dl">"</span><span class="p">;</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">Vue</span><span class="p">.</span><span class="nf">extend</span><span class="p">({</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">BasicCounter</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">props</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">index</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
  <span class="p">},</span>
  <span class="na">data</span><span class="p">:</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span>
      <span class="na">counter</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
    <span class="p">};</span>
  <span class="p">},</span>
  <span class="na">methods</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">increment</span><span class="p">:</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">counter</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">counter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">},</span>
    <span class="na">decrement</span><span class="p">:</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">counter</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">counter</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">},</span>
  <span class="p">},</span>
<span class="p">});</span>
<span class="nt">&lt;/</span><span class="k">script</span><span class="nt">&gt;</span>

<span class="c">&lt;!-- Add "scoped" attribute to limit CSS to this component only --&gt;</span>
<span class="nt">&lt;</span><span class="k">style</span> <span class="na">scoped</span> <span class="na">lang=</span><span class="s">"scss"</span><span class="nt">&gt;</span>
<span class="nc">.basic-counter</span> <span class="p">{</span>
  <span class="nl">display</span><span class="p">:</span> <span class="n">flex</span><span class="p">;</span>
  <span class="nl">flex-direction</span><span class="p">:</span> <span class="n">column</span><span class="p">;</span>

  <span class="nt">h3</span> <span class="p">{</span>
    <span class="nl">margin</span><span class="p">:</span> <span class="m">40px</span> <span class="m">0</span> <span class="m">0</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="nc">.counter</span> <span class="p">{</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="nt">&lt;/</span><span class="k">style</span><span class="nt">&gt;</span>
</code></pre></div></div>

<p>TwoCounter.vue</p>

<div class="language-vue highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;</span><span class="k">template</span><span class="nt">&gt;</span>
  <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"two-counter"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;h1&gt;</span><span class="si">{{</span> <span class="nx">title</span> <span class="si">}}</span><span class="nt">&lt;/h1&gt;</span>
    <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"counters"</span><span class="nt">&gt;</span>
      <span class="nt">&lt;BasicCounter</span> <span class="na">index=</span><span class="s">"1"</span> <span class="nt">/&gt;</span>
      <span class="nt">&lt;BasicCounter</span> <span class="na">index=</span><span class="s">"2"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;/div&gt;</span>
  <span class="nt">&lt;/div&gt;</span>
<span class="nt">&lt;/</span><span class="k">template</span><span class="nt">&gt;</span>

<span class="nt">&lt;</span><span class="k">script</span> <span class="na">lang=</span><span class="s">"ts"</span><span class="nt">&gt;</span>
<span class="k">import</span> <span class="nx">Vue</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">vue</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">BasicCounter</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">./BasicCounter.vue</span><span class="dl">"</span><span class="p">;</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">Vue</span><span class="p">.</span><span class="nf">extend</span><span class="p">({</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">TwoCounter</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">components</span><span class="p">:</span> <span class="p">{</span>
    <span class="nx">BasicCounter</span><span class="p">,</span>
  <span class="p">},</span>
  <span class="na">props</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">title</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
  <span class="p">},</span>
<span class="p">});</span>
<span class="nt">&lt;/</span><span class="k">script</span><span class="nt">&gt;</span>

<span class="c">&lt;!-- Add "scoped" attribute to limit CSS to this component only --&gt;</span>
<span class="nt">&lt;</span><span class="k">style</span> <span class="na">scoped</span> <span class="na">lang=</span><span class="s">"scss"</span><span class="nt">&gt;</span>
<span class="nc">.two-counter</span> <span class="p">{</span>
  <span class="nl">width</span><span class="p">:</span> <span class="m">800px</span><span class="p">;</span>
  <span class="nc">.counters</span> <span class="p">{</span>
    <span class="nl">display</span><span class="p">:</span> <span class="n">flex</span><span class="p">;</span>
    <span class="nl">flex-direction</span><span class="p">:</span> <span class="n">row</span><span class="p">;</span>
    <span class="nl">justify-content</span><span class="p">:</span> <span class="n">space-around</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="nt">&lt;/</span><span class="k">style</span><span class="nt">&gt;</span>
</code></pre></div></div>

<p>写好之后, 使用以下命令编译成 Web Component:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> yarn run build <span class="nt">--</span> <span class="nt">--target</span> <span class="nb">wc</span> <span class="nt">--name</span> two-counter <span class="nt">--inline-vue</span> src/components/TwoCounter.vue
</code></pre></div></div>

<p>上面的命令会在 dist 里面生成一个叫做 <code class="language-plaintext highlighter-rouge">two-counter.js</code> 的文件, 可以直接在 html 里面引用它:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="nt">&lt;html</span> <span class="na">lang=</span><span class="s">""</span><span class="nt">&gt;</span>
  <span class="nt">&lt;head&gt;</span>
    <span class="nt">&lt;meta</span> <span class="na">charset=</span><span class="s">"utf-8"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;title&gt;</span>two-counter<span class="nt">&lt;/title&gt;</span>
    <span class="nt">&lt;script </span><span class="na">src=</span><span class="s">"./two-counter.js"</span><span class="nt">&gt;&lt;/script&gt;</span>
  <span class="nt">&lt;/head&gt;</span>
  <span class="nt">&lt;body&gt;</span>
    <span class="nt">&lt;two-counter&gt;&lt;/two-counter&gt;</span>
  <span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</code></pre></div></div>

<p>最后的运行效果如下:</p>

<p><img src="https://qiniu.iuwei.fun/blog/front-end/vue/two-counter-web-component.jpg" alt="" /></p>

<h2 id="vue-3">Vue 3</h2>

<p>如果你用的是 Vue 3, 目前它对 Web Component 的支持有限, 需要使用一种变通的方式来生成.</p>

<p>创建一个包装性质的代码片段:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">createApp</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">vue</span><span class="dl">"</span><span class="p">;</span>

<span class="k">import</span> <span class="nx">App</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">./App.vue</span><span class="dl">"</span><span class="p">;</span>

<span class="kd">class</span> <span class="nc">CustomElement</span> <span class="kd">extends</span> <span class="nc">HTMLElement</span> <span class="p">{</span>
  <span class="nf">constructor</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">super</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="nf">connectedCallback</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">options</span> <span class="o">=</span> <span class="k">typeof</span> <span class="nx">App</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">function</span><span class="dl">"</span> <span class="p">?</span> <span class="nx">App</span><span class="p">.</span><span class="nx">options</span> <span class="p">:</span> <span class="nx">App</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">propsList</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="nf">isArray</span><span class="p">(</span><span class="nx">options</span><span class="p">.</span><span class="nx">props</span><span class="p">)</span>
      <span class="p">?</span> <span class="nx">options</span><span class="p">.</span><span class="nx">props</span>
      <span class="p">:</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">keys</span><span class="p">(</span><span class="nx">options</span><span class="p">.</span><span class="nx">props</span> <span class="o">||</span> <span class="p">{});</span>

    <span class="kd">const</span> <span class="nx">props</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="c1">// Validate, if all props are present</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">const</span> <span class="nx">prop</span> <span class="k">of</span> <span class="nx">propsList</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">propValue</span> <span class="o">=</span>
        <span class="nx">process</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">NODE_ENV</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">development</span><span class="dl">"</span>
          <span class="p">?</span> <span class="nx">process</span><span class="p">.</span><span class="nx">env</span><span class="p">[</span><span class="s2">`VUE_APP_</span><span class="p">${</span><span class="nx">prop</span><span class="p">.</span><span class="nf">toUpperCase</span><span class="p">()}</span><span class="s2">`</span><span class="p">]</span>
          <span class="p">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">attributes</span><span class="p">.</span><span class="nf">getNamedItem</span><span class="p">(</span><span class="nx">prop</span><span class="p">)?.</span><span class="nx">value</span><span class="p">;</span>

      <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nx">propValue</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nf">error</span><span class="p">(</span><span class="s2">`Missing attribute </span><span class="p">${</span><span class="nx">prop</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="nx">props</span><span class="p">[</span><span class="nx">prop</span><span class="p">]</span> <span class="o">=</span> <span class="nx">propValue</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">const</span> <span class="nx">app</span> <span class="o">=</span> <span class="nf">createApp</span><span class="p">(</span><span class="nx">App</span><span class="p">,</span> <span class="nx">props</span><span class="p">);</span>

    <span class="kd">const</span> <span class="nx">wrapper</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createElement</span><span class="p">(</span><span class="dl">"</span><span class="s2">div</span><span class="dl">"</span><span class="p">);</span>
    <span class="nx">app</span><span class="p">.</span><span class="nf">mount</span><span class="p">(</span><span class="nx">wrapper</span><span class="p">);</span>

    <span class="k">this</span><span class="p">.</span><span class="nf">appendChild</span><span class="p">(</span><span class="nx">wrapper</span><span class="p">.</span><span class="nx">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nb">window</span><span class="p">.</span><span class="nx">customElements</span><span class="p">.</span><span class="nf">define</span><span class="p">(</span><span class="dl">"</span><span class="s2">two-counter</span><span class="dl">"</span><span class="p">,</span> <span class="nx">CustomElement</span><span class="p">);</span>
</code></pre></div></div>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> yarn run build <span class="nt">--</span> <span class="nt">--target</span> lib <span class="nt">--name</span> two-counter <span class="nt">--inline-vue</span> src/two-counter.js
</code></pre></div></div>]]></content><author><name>Zhigang Song</name></author><category term="javascript" /><category term="vue" /><summary type="html"><![CDATA[准备 安装 vue 命令行工具: &gt; yarn global add @vue/cli 生成一个空白仓库: &gt; vue create json-viewer 可以使用的选项如下(参考, 根据自己的需要调整):]]></summary></entry><entry><title type="html">决策树算法</title><link href="http://sidgwick.github.io/2023/09/20/decison-tree.html" rel="alternate" type="text/html" title="决策树算法" /><published>2023-09-20T05:14:41+08:00</published><updated>2023-09-20T05:14:41+08:00</updated><id>http://sidgwick.github.io/2023/09/20/decison-tree</id><content type="html" xml:base="http://sidgwick.github.io/2023/09/20/decison-tree.html"><![CDATA[<h1 id="算法原理">算法原理</h1>

<h2 id="树模型">树模型</h2>

<p>从<strong>决策树</strong>根节点开始一步步走到叶子节点(决策), 所有的数据最终都会落到叶子节点, 利用决策树既可以做分类也可以做回归.</p>

<p>树的组成</p>

<ul>
  <li><strong>根节点</strong>: 第一个选择点</li>
  <li><strong>非叶子节点与分支</strong>: 中间过程</li>
  <li><strong>叶子节点</strong>: 最终的决策结果</li>
</ul>

<p>决策树的训练是从给定的训练集构造(从根节点开始选择特征, 如何进行特征切分)出来一棵树, 然后将测试数据根据构造出来的树模型从上到下去走一遍, 得到决策结果.</p>

<p>一旦构造好了决策树, 那么分类或者预测任务就很简单了, 只需跟着树走一遍决策流程就可以了, 那么难点就在于如何构造出来一颗树.</p>

<!--more-->

<h2 id="熵的作用">熵的作用</h2>

<p>根节点的选择该用哪个特征呢? 我们的目标应该是经过根节点的决策之后尽可能好的切分数据(即决策后分类的效果更好), 然后再找除了根节点用到的特征之外的其他特征中切分效果最好的特征作为决策树的后续节点, 然后是第三好, 第四好…</p>

<p>所以我们需要一种衡量标准, 来计算通过不同特征进行分支选择后的分类 情况, 找出来最好的那个当成根节点.</p>

<h3 id="熵">熵</h3>

<p>熵是表示随机变量不确定性的度量, 它的定义如下:</p>

\[H(X) = -\sum_{i=1}^{n} p_{i}\log{p_{i}}\]

<p>举例有 $A = \lbrace 1,1,1,1,1,1,1,1,2,2 \rbrace$, $B=\lbrace 1,2,3,4,5,6,7,8,9,1 \rbrace$ 两个集合, 显然 $A$ 集合的熵值要低，因为 $A$ 里面只有两种类别, 相对稳定一些. 而 $B$ 中类别太多了, 熵值就会大很多. (在分类任务中我们希望通过节点分支后数据类别的熵值大还是小呢?)</p>

<h2 id="信息增益原理">信息增益原理</h2>

<p>集合中的信息越混乱, 得到的熵值也就越大. 如当 $p=0$ 或 $p=1$ 时, $H(p)=0$, 随机变量完全没有不确定性. 当 $p=0.5$ 时, $H(p)=1$, 此时随机变量的不确定性最大.</p>

<h3 id="信息增益">信息增益</h3>

<p>指的是在经过特征 $X$ 的分类之后, 使得结果熵相对于分类操作之前的熵的减小值.</p>

<h1 id="决策树构造实例">决策树构造实例</h1>

<p>现在有一个表, 其中数据列举了人的幸福与否和年龄,工作,家庭,贷款情况的关系, 我们基于这张表构建一个决策树.</p>

<p>首先我们可以计算得到, 根节点的信息熵为(6 个 <code class="language-plaintext highlighter-rouge">no</code>, 9 个 <code class="language-plaintext highlighter-rouge">yes</code>):</p>

\[\begin{aligned}
H ~=~&amp; - \frac{6}{15} \times \log{\frac{6}{15}} - \frac{9}{15} \times \log{\frac{9}{15}} \\
  \approx ~&amp; 0.97095
\end{aligned}\]

<p>然后对 4 个特征逐一分析, 分别尝试用他们作为决策依据, 看一下决策后那个特征对应的信息增益最大, 就可以认定这个特征是最好的分类特征. 要注意的是, 用特征切分原始数据集之后, 切分结果对应的信息熵是一个加权平均熵.</p>

<p>我们以 <code class="language-plaintext highlighter-rouge">F3-HOME</code> 特征分类来讲解. 它可以把数据分类为 2 个集合(这个特征有两个特征值).</p>

<p>在特征值为 0 的情况下, 有 6 个 <code class="language-plaintext highlighter-rouge">no</code> 值, 3 个 <code class="language-plaintext highlighter-rouge">yes</code> 值.
在特征值为 1 的情况下, 有 0 个 <code class="language-plaintext highlighter-rouge">no</code> 值, 6 个 <code class="language-plaintext highlighter-rouge">yes</code> 值.</p>

\[\begin{aligned}
H_{3} ~=~&amp; \frac{9}{15} \times (-\frac{6}{9} \times \log{\frac{6}{9}} - \frac{3}{9} \times \log{\frac{3}{9}}) + \frac{6}{15} \times (-\frac{0}{6} \times \log{\frac{0}{6}} - \frac{6}{6} \times \log{\frac{6}{6}})  \\
  \approx ~&amp; 0.55097
\end{aligned}\]

<p>用同样的办法, 可以求出来其他切分方式的熵值:</p>

\[\begin{aligned}
H_1 \approx ~&amp; 0.88794 \\
H_2 \approx ~&amp; 0.64730 \\
H_4 \approx ~&amp; 0.60796
\end{aligned}\]

<p>可以看到使用 <code class="language-plaintext highlighter-rouge">F3-HOME</code> 特征, 信息增益是最大的, 因此可以选择它作为根节点.</p>

<p>接下来对于各个特征子树的节点, 构建下一层的决策树时候就是在子数据集合基础上, 再找最优特征作为分类依据. 更深一层的节点也是一样的原理.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">Union</span>

<span class="kn">import</span> <span class="n">math</span>
<span class="kn">import</span> <span class="n">json</span>


<span class="c1"># 创建数据
</span><span class="k">def</span> <span class="nf">createDataSet</span><span class="p">():</span>
    <span class="c1"># 数据
</span>    <span class="n">dataSet</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sh">"</span><span class="s">no</span><span class="sh">"</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="sh">"</span><span class="s">no</span><span class="sh">"</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="sh">"</span><span class="s">yes</span><span class="sh">"</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sh">"</span><span class="s">yes</span><span class="sh">"</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sh">"</span><span class="s">no</span><span class="sh">"</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sh">"</span><span class="s">no</span><span class="sh">"</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="sh">"</span><span class="s">no</span><span class="sh">"</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="sh">"</span><span class="s">yes</span><span class="sh">"</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="sh">"</span><span class="s">yes</span><span class="sh">"</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="sh">"</span><span class="s">yes</span><span class="sh">"</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="sh">"</span><span class="s">yes</span><span class="sh">"</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="sh">"</span><span class="s">yes</span><span class="sh">"</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="sh">"</span><span class="s">yes</span><span class="sh">"</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="sh">"</span><span class="s">yes</span><span class="sh">"</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sh">"</span><span class="s">no</span><span class="sh">"</span><span class="p">],</span>
    <span class="p">]</span>

    <span class="c1"># 列名
</span>    <span class="n">features</span> <span class="o">=</span> <span class="p">[</span><span class="sh">"</span><span class="s">F1-AGE</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">F2-WORK</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">F3-HOME</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">F4-LOAN</span><span class="sh">"</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">dataSet</span><span class="p">,</span> <span class="n">features</span>


<span class="k">def</span> <span class="nf">maxDataSetLabel</span><span class="p">(</span><span class="n">dsLabelList</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">找到 dsLabelList 中元素的众数并返回</span><span class="sh">"""</span>
    <span class="n">counter</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">dsLabelList</span><span class="p">:</span>
        <span class="n">cnt</span> <span class="o">=</span> <span class="n">counter</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">cnt</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">counter</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cnt</span>

    <span class="n">key</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">counter</span><span class="p">.</span><span class="n">get</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">key</span>


<span class="k">def</span> <span class="nf">dataSetEntropy</span><span class="p">(</span><span class="n">dataSet</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">计算 dataSet 的熵值</span><span class="sh">"""</span>
    <span class="n">counter</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">dataSet</span><span class="p">:</span>
        <span class="n">label</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">cnt</span> <span class="o">=</span> <span class="n">counter</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">counter</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="n">cnt</span>

    <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">total</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">dataSet</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">counter</span><span class="p">.</span><span class="nf">values</span><span class="p">():</span>
        <span class="n">prob</span> <span class="o">=</span> <span class="n">val</span> <span class="o">/</span> <span class="n">total</span>
        <span class="n">result</span> <span class="o">-=</span> <span class="n">prob</span> <span class="o">*</span> <span class="n">math</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="n">prob</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">weightSubDataSetEntropy</span><span class="p">(</span><span class="n">subDataSet</span><span class="p">,</span> <span class="n">dataSetLen</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">计算按照特征拆分好的子数据集的加权熵</span><span class="sh">"""</span>
    <span class="n">entropy</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">dataSetLen</span> <span class="o">=</span> <span class="nf">float</span><span class="p">(</span><span class="n">dataSetLen</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">_dataSet</span> <span class="ow">in</span> <span class="n">subDataSet</span><span class="p">.</span><span class="nf">values</span><span class="p">():</span>
        <span class="n">_entropy</span> <span class="o">=</span> <span class="nf">dataSetEntropy</span><span class="p">(</span><span class="n">_dataSet</span><span class="p">)</span>
        <span class="n">entropy</span> <span class="o">+=</span> <span class="n">_entropy</span> <span class="o">*</span> <span class="nf">len</span><span class="p">(</span><span class="n">_dataSet</span><span class="p">)</span> <span class="o">/</span> <span class="n">dataSetLen</span>

    <span class="k">return</span> <span class="n">entropy</span>


<span class="k">def</span> <span class="nf">chooseBestFeatureToSplit</span><span class="p">(</span><span class="n">dataSet</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">计算信息增益最大的特征

    1. 计算分裂之前的熵值
    2. 找到可以用于分裂的特征列表
    3. 尝试使用 2 里面的每个特征分裂构造子树, 然后判断那个信息增益最大
    4. 使用信息增益最大的那个特征, 构造分类节点数据
    </span><span class="sh">"""</span>
    <span class="n">dsLen</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">dataSet</span><span class="p">)</span>
    <span class="n">numberFeatures</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">dataSet</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># number of features
</span>    <span class="n">curEntropy</span> <span class="o">=</span> <span class="nf">dataSetEntropy</span><span class="p">(</span><span class="n">dataSet</span><span class="p">)</span>  <span class="c1"># initial entropy
</span>
    <span class="n">bestGain</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">bestFeatIndex</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">for</span> <span class="n">feat</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">numberFeatures</span><span class="p">):</span>
        <span class="n">subDataSet</span> <span class="o">=</span> <span class="nf">subDataSetByFeature</span><span class="p">(</span><span class="n">dataSet</span><span class="p">,</span> <span class="n">feat</span><span class="p">)</span>
        <span class="n">entropy</span> <span class="o">=</span> <span class="nf">weightSubDataSetEntropy</span><span class="p">(</span><span class="n">subDataSet</span><span class="p">,</span> <span class="n">dsLen</span><span class="p">)</span>

        <span class="n">gain</span> <span class="o">=</span> <span class="n">curEntropy</span> <span class="o">-</span> <span class="n">entropy</span>
        <span class="k">if</span> <span class="n">gain</span> <span class="o">&gt;</span> <span class="n">bestGain</span><span class="p">:</span>
            <span class="n">bestGain</span> <span class="o">=</span> <span class="n">gain</span>
            <span class="n">bestFeatIndex</span> <span class="o">=</span> <span class="n">feat</span>

    <span class="k">return</span> <span class="n">bestFeatIndex</span>


<span class="k">def</span> <span class="nf">subDataSetByFeature</span><span class="p">(</span><span class="n">dataSet</span><span class="p">,</span> <span class="n">bestFeatIndex</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">按照 bestFeatIndex 指示的特征, 将 dataSet 分类</span><span class="sh">"""</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">dataSet</span><span class="p">:</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">bestFeatIndex</span><span class="p">]</span>

        <span class="n">valList</span> <span class="o">=</span> <span class="n">result</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="p">[])</span>
        <span class="n">valList</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">row</span><span class="p">[:</span><span class="n">bestFeatIndex</span><span class="p">]</span> <span class="o">+</span> <span class="n">row</span><span class="p">[</span><span class="n">bestFeatIndex</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:])</span>
        <span class="n">result</span><span class="p">[</span><span class="n">val</span><span class="p">]</span> <span class="o">=</span> <span class="n">valList</span>

    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">createTreeNode</span><span class="p">(</span><span class="n">dataSet</span><span class="p">,</span> <span class="n">labelList</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">dict</span><span class="p">]:</span>
    <span class="sh">"""</span><span class="s">
    创建决策树
    :param dataSet: 数据集
    :param features: 特征列表
    :return: 决策树
    </span><span class="sh">"""</span>
    <span class="c1"># 当前数据集合中, 标签数据
</span>    <span class="n">dsLabelList</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">dataSet</span><span class="p">]</span>

    <span class="c1"># 已经分好类别, 节点不需要再分裂了
</span>    <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="nf">set</span><span class="p">(</span><span class="n">dsLabelList</span><span class="p">))</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">dsLabelList</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># label 虽然还没有完全分开, 但是已经没有特征可供拆分了, 统计众数, 作为标签返回
</span>    <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">labelList</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="nf">maxDataSetLabel</span><span class="p">(</span><span class="n">dsLabelList</span><span class="p">)</span>

    <span class="c1"># 找到最优的特征用于分裂
</span>    <span class="n">bestFeatIndex</span> <span class="o">=</span> <span class="nf">chooseBestFeatureToSplit</span><span class="p">(</span><span class="n">dataSet</span><span class="p">)</span>
    <span class="n">bestFeat</span> <span class="o">=</span> <span class="n">labelList</span><span class="p">[</span><span class="n">bestFeatIndex</span><span class="p">]</span>

    <span class="c1"># 删除被选择的特征
</span>    <span class="k">del</span> <span class="n">labelList</span><span class="p">[</span><span class="n">bestFeatIndex</span><span class="p">]</span>

    <span class="c1"># 按照特征, 将数据分成不同的子集
</span>    <span class="n">subDataSet</span> <span class="o">=</span> <span class="nf">subDataSetByFeature</span><span class="p">(</span><span class="n">dataSet</span><span class="p">,</span> <span class="n">bestFeatIndex</span><span class="p">)</span>

    <span class="c1"># 遍历每个特征值, 然后递归的构造子树
</span>    <span class="n">node</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">featVal</span><span class="p">,</span> <span class="n">_dataSet</span> <span class="ow">in</span> <span class="n">subDataSet</span><span class="p">.</span><span class="nf">items</span><span class="p">():</span>
        <span class="n">_labelList</span> <span class="o">=</span> <span class="n">labelList</span><span class="p">.</span><span class="nf">copy</span><span class="p">()</span>
        <span class="n">node</span><span class="p">[</span><span class="n">featVal</span><span class="p">]</span> <span class="o">=</span> <span class="nf">createTreeNode</span><span class="p">(</span><span class="n">_dataSet</span><span class="p">,</span> <span class="n">_labelList</span><span class="p">)</span>

    <span class="c1"># 创建树
</span>    <span class="n">tree</span> <span class="o">=</span> <span class="p">{</span><span class="n">bestFeat</span><span class="p">:</span> <span class="n">node</span><span class="p">}</span>
    <span class="k">return</span> <span class="n">tree</span>


<span class="n">dataSet</span><span class="p">,</span> <span class="n">features</span> <span class="o">=</span> <span class="nf">createDataSet</span><span class="p">()</span>

<span class="n">tree</span> <span class="o">=</span> <span class="nf">createTreeNode</span><span class="p">(</span><span class="n">dataSet</span><span class="p">,</span> <span class="n">features</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">json</span><span class="p">.</span><span class="nf">dumps</span><span class="p">(</span><span class="n">tree</span><span class="p">))</span>
</code></pre></div></div>

<h1 id="信息增益率与-gini-系数">信息增益率与 gini 系数</h1>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>决策树算法
ID3
信息增益(有什么问题呢?)

问题：ID当做特征，熵值为0，不适合解决稀疏特征，种类非常多的。

C4.5
信息增益率(解决ID3问题，考虑自身熵)

CART
使用GINI系数来当做衡量标准

GINI系数
\large Gini(p)=\sum_{k=1}^{K}p_{k}(1-p_{k})=1-\sum_{k=1}^{K}p_{k}^{2}

(和熵的衡量标准类似，计算方式不相同)

连续值
进行离散化。



六、预剪枝方法
决策树剪枝策略
为什么要剪枝
决策树过拟合风险很大，理论上可以完全分得开数据 (想象一下，如果树足够庞大，每个叶子节点不就一个数据了嘛)

剪枝策略
（预剪枝，后减枝）

预剪枝
边建立决策树过程中进行剪枝的操作(更实用)。

限制深度，叶子节点个数。叶子节点样本数，信息增益量等。

七、后剪枝方法
后剪枝：当建立完决策树后来进行剪枝操作。

通过一定的衡量标准\large C_{a}(T)=C(T)+\alpha \left | T_{leaf} \right |

 \large C_{a}(T)：损失

\large C(T)：gini系数

\large T_{leaf}：叶子节点个数

(叶子节点越多，损失越大)



八、回归问题解决
回归问题将方差作为衡量（评估）标准。看标签的平均方差。

分类问题将熵值作为衡量标准。
</code></pre></div></div>

<h1 id="参考资料">参考资料</h1>

<ul>
  <li><a href="https://zhuanlan.zhihu.com/p/435152553">非常好 - 深刻理解决策树-动手计算 ID3 算法</a></li>
</ul>]]></content><author><name>Zhigang Song</name></author><category term="ai" /><category term="decision-tree" /><summary type="html"><![CDATA[算法原理 树模型 从决策树根节点开始一步步走到叶子节点(决策), 所有的数据最终都会落到叶子节点, 利用决策树既可以做分类也可以做回归. 树的组成 根节点: 第一个选择点 非叶子节点与分支: 中间过程 叶子节点: 最终的决策结果 决策树的训练是从给定的训练集构造(从根节点开始选择特征, 如何进行特征切分)出来一棵树, 然后将测试数据根据构造出来的树模型从上到下去走一遍, 得到决策结果. 一旦构造好了决策树, 那么分类或者预测任务就很简单了, 只需跟着树走一遍决策流程就可以了, 那么难点就在于如何构造出来一颗树.]]></summary></entry><entry><title type="html">用树回归方法画股票趋势线</title><link href="http://sidgwick.github.io/2023/09/17/linear-regression-decision-tree-trending.html" rel="alternate" type="text/html" title="用树回归方法画股票趋势线" /><published>2023-09-17T05:34:04+08:00</published><updated>2023-09-17T05:34:04+08:00</updated><id>http://sidgwick.github.io/2023/09/17/linear-regression-decision-tree-trending</id><content type="html" xml:base="http://sidgwick.github.io/2023/09/17/linear-regression-decision-tree-trending.html"><![CDATA[<p>原文: <a href="https://www.jianshu.com/p/f2a4cbe388a9">机器学习_用树回归方法画股票趋势线</a></p>

<p>本篇的主题是分段线性拟合, 也叫回归树, 是一种集成算法, 它同时使用了决策和线性回归的原理, 其中有两点不太容易理解, 一个是决策树中熵的概念, 一个是线性拟合时求参数的公式为什么是由矩阵乘法实现的. 如需详解, 请见前篇:</p>

<ul>
  <li><a href="http://blog.csdn.net/xieyan0811/article/details/78556366">《机器学习_决策树与信息熵》</a></li>
  <li><a href="http://blog.csdn.net/xieyan0811/article/details/78562610">《机器学习_最小二乘法，线性回归与逻辑回归》</a></li>
</ul>

<h1 id="画出股票的趋势线">画出股票的趋势线</h1>

<p>我们常在股票节目里看到这样的趋势线:</p>

<p><img src="https://qiniu.iuwei.fun/blog/algorithm/%E8%B6%8B%E5%8A%BF%E7%BA%BF.png" alt="趋势线" /></p>

<!--more-->

<p>比如说平台突破就可以买入了, 几千支股票, 能不能用程序的方式筛选哪支突破了呢? 需要解决的主要问题是: 怎么判断一段时间内股票的涨/跌/横盘, 以及一段趋势的起止点和角度呢?</p>

<p><img src="https://qiniu.iuwei.fun/blog/algorithm/%E5%88%86%E6%AE%B5%E7%BA%BF%E6%80%A7%E6%8B%9F%E5%90%88.png" alt="分段线性拟合" /></p>

<p>这里我们使用分段线性拟合, 图中蓝色的点是某支股票每日的收盘价, 红色的直线为程序画出的趋势线. 稍做修改, 还可以轻松地画出每段趋势所在的箱体, 阻力线和支撑线, 以及判断此前一般时间的趋势. 下面我们就来看看原理和具体算法.</p>

<h1 id="相关算法">相关算法</h1>

<h2 id="线性回归">线性回归</h2>

<p>先看看线性回归(Linear regression), 线性回归是利用数理统计中回归分析, 来确定两种或两种以上变量间相互依赖的定量关系的一种统计分析方法. 简单地说, 二维中就是画一条直线, 让它离所有点都尽量地近(距离之和最小), 用线抽象地表达这些点. 具体请见<a href="http://blog.csdn.net/xieyan0811/article/details/78562610">《机器学习_最小二乘法，线性回归与逻辑回归》</a></p>

<p><img src="https://qiniu.iuwei.fun/blog/algorithm/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92.png" alt="线性回归" /></p>

<h2 id="决策树">决策树</h2>

<p>我们再看看决策树, 决策树(Decision Tree)决策树是一个预测模型: 它是通过一系列的判断达到决策的方法. 具体请见<a href="http://blog.csdn.net/xieyan0811/article/details/78556366">《机器学习_决策树与信息熵》</a>.</p>

<p><img src="https://qiniu.iuwei.fun/blog/algorithm/%E5%86%B3%E7%AD%96%E6%A0%91.png" alt="决策树" /></p>

<h2 id="树回归">树回归</h2>

<p>树回归把决策树和线性回归集成在一起, 先决策树, 在每个叶节点上构建一个线性方程. 比如说数据的最佳拟合是一条折线, 那就把它切成几段用线性拟合, 每段切多长呢? 我们定义一个步长(以忽略小的波动, 更好地控制周期), 在整个区域上遍历, 找最合适的点(树的分叉点), 用该点切分成两段后, 分别线性拟合, 取整体误差和最小的点. 以此类拟, 再分到三段, 四段…, 为避免过拟合, 具体实现一般同时使用前剪枝和后剪枝.</p>

<h1 id="代码">代码</h1>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># -*- coding: utf-8 -*-
</span>
<span class="kn">import</span> <span class="n">tushare</span> <span class="k">as</span> <span class="n">ts</span>
<span class="kn">import</span> <span class="n">pandas</span> <span class="k">as</span> <span class="n">pd</span>
<span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="n">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>


<span class="c1"># 用feature把dataSet按value分成两个子集
</span><span class="k">def</span> <span class="nf">binSplitDataSet</span><span class="p">(</span><span class="n">dataSet</span><span class="p">,</span> <span class="n">feature</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="n">mat0</span> <span class="o">=</span> <span class="n">dataSet</span><span class="p">[</span><span class="n">np</span><span class="p">.</span><span class="nf">nonzero</span><span class="p">(</span><span class="n">dataSet</span><span class="p">[:,</span> <span class="n">feature</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">value</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:]</span>
    <span class="n">mat1</span> <span class="o">=</span> <span class="n">dataSet</span><span class="p">[</span><span class="n">np</span><span class="p">.</span><span class="nf">nonzero</span><span class="p">(</span><span class="n">dataSet</span><span class="p">[:,</span> <span class="n">feature</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">value</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:]</span>
    <span class="k">return</span> <span class="n">mat0</span><span class="p">,</span> <span class="n">mat1</span>


<span class="c1"># 求给定数据集的线性方程
</span><span class="k">def</span> <span class="nf">linearSolve</span><span class="p">(</span><span class="n">dataSet</span><span class="p">):</span>
    <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">shape</span><span class="p">(</span><span class="n">dataSet</span><span class="p">)</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">mat</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">ones</span><span class="p">((</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">)))</span>
    <span class="c1"># 第一行补1，线性拟合要求
</span>    <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">mat</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">ones</span><span class="p">((</span><span class="n">m</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
    <span class="n">X</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">dataSet</span><span class="p">[:,</span> <span class="mi">0</span> <span class="p">:</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="n">dataSet</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># 数据最后一列是y
</span>    <span class="n">xTx</span> <span class="o">=</span> <span class="n">X</span><span class="p">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">X</span>
    <span class="k">if</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="nf">det</span><span class="p">(</span><span class="n">xTx</span><span class="p">)</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="nc">NameError</span><span class="p">(</span>
            <span class="sh">"</span><span class="s">This matrix is singular, cannot do inverse,</span><span class="se">\n\
</span><span class="s">        try increasing dur</span><span class="sh">"</span>
        <span class="p">)</span>
    <span class="n">ws</span> <span class="o">=</span> <span class="n">xTx</span><span class="p">.</span><span class="n">I</span> <span class="o">*</span> <span class="p">(</span><span class="n">X</span><span class="p">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">Y</span><span class="p">)</span>  <span class="c1"># 公式推导较难理解
</span>    <span class="k">return</span> <span class="n">ws</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span>


<span class="c1"># 求线性方程的参数
</span><span class="k">def</span> <span class="nf">modelLeaf</span><span class="p">(</span><span class="n">dataSet</span><span class="p">):</span>
    <span class="n">ws</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="nf">linearSolve</span><span class="p">(</span><span class="n">dataSet</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ws</span>


<span class="c1"># 预测值和y的方差
</span><span class="k">def</span> <span class="nf">modelErr</span><span class="p">(</span><span class="n">dataSet</span><span class="p">):</span>
    <span class="n">ws</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="nf">linearSolve</span><span class="p">(</span><span class="n">dataSet</span><span class="p">)</span>
    <span class="n">yHat</span> <span class="o">=</span> <span class="n">X</span> <span class="o">*</span> <span class="n">ws</span>
    <span class="k">return</span> <span class="nf">sum</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">power</span><span class="p">(</span><span class="n">Y</span> <span class="o">-</span> <span class="n">yHat</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">chooseBestSplit</span><span class="p">(</span><span class="n">dataSet</span><span class="p">,</span> <span class="n">rate</span><span class="p">,</span> <span class="n">dur</span><span class="p">):</span>
    <span class="c1"># 判断所有样本是否为同一分类
</span>    <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="nf">set</span><span class="p">(</span><span class="n">dataSet</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">T</span><span class="p">.</span><span class="nf">tolist</span><span class="p">()[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span><span class="p">,</span> <span class="nf">modelLeaf</span><span class="p">(</span><span class="n">dataSet</span><span class="p">)</span>
    <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">shape</span><span class="p">(</span><span class="n">dataSet</span><span class="p">)</span>
    <span class="n">S</span> <span class="o">=</span> <span class="nf">modelErr</span><span class="p">(</span><span class="n">dataSet</span><span class="p">)</span>  <span class="c1"># 整体误差
</span>    <span class="n">bestS</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">inf</span>
    <span class="n">bestIndex</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">bestValue</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">featIndex</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>  <span class="c1"># 遍历所有特征, 此处只有一个
</span>        <span class="c1"># 遍历特征中每种取值
</span>        <span class="k">for</span> <span class="n">splitVal</span> <span class="ow">in</span> <span class="nf">set</span><span class="p">(</span><span class="n">dataSet</span><span class="p">[:,</span> <span class="n">featIndex</span><span class="p">].</span><span class="n">T</span><span class="p">.</span><span class="nf">tolist</span><span class="p">()[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">mat0</span><span class="p">,</span> <span class="n">mat1</span> <span class="o">=</span> <span class="nf">binSplitDataSet</span><span class="p">(</span><span class="n">dataSet</span><span class="p">,</span> <span class="n">featIndex</span><span class="p">,</span> <span class="n">splitVal</span><span class="p">)</span>
            <span class="nf">if </span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">shape</span><span class="p">(</span><span class="n">mat0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">dur</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">shape</span><span class="p">(</span><span class="n">mat1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">dur</span><span class="p">):</span>
                <span class="k">continue</span>  <span class="c1"># 样本数太少, 前剪枝
</span>            <span class="n">newS</span> <span class="o">=</span> <span class="nf">modelErr</span><span class="p">(</span><span class="n">mat0</span><span class="p">)</span> <span class="o">+</span> <span class="nf">modelErr</span><span class="p">(</span><span class="n">mat1</span><span class="p">)</span>  <span class="c1"># 计算整体误差
</span>            <span class="k">if</span> <span class="n">newS</span> <span class="o">&lt;</span> <span class="n">bestS</span><span class="p">:</span>
                <span class="n">bestIndex</span> <span class="o">=</span> <span class="n">featIndex</span>
                <span class="n">bestValue</span> <span class="o">=</span> <span class="n">splitVal</span>
                <span class="n">bestS</span> <span class="o">=</span> <span class="n">newS</span>
    <span class="nf">if </span><span class="p">(</span><span class="n">S</span> <span class="o">-</span> <span class="n">bestS</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">rate</span><span class="p">:</span>  <span class="c1"># 如差误差下降得太少，则不切分
</span>        <span class="k">return</span> <span class="bp">None</span><span class="p">,</span> <span class="nf">modelLeaf</span><span class="p">(</span><span class="n">dataSet</span><span class="p">)</span>
    <span class="n">mat0</span><span class="p">,</span> <span class="n">mat1</span> <span class="o">=</span> <span class="nf">binSplitDataSet</span><span class="p">(</span><span class="n">dataSet</span><span class="p">,</span> <span class="n">bestIndex</span><span class="p">,</span> <span class="n">bestValue</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">bestIndex</span><span class="p">,</span> <span class="n">bestValue</span>


<span class="k">def</span> <span class="nf">isTree</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="k">return</span> <span class="nf">type</span><span class="p">(</span><span class="n">obj</span><span class="p">).</span><span class="n">__name__</span> <span class="o">==</span> <span class="sh">"</span><span class="s">dict</span><span class="sh">"</span>


<span class="c1"># 预测函数,数据乘模型,模型是斜率和截距的矩阵
</span><span class="k">def</span> <span class="nf">modelTreeEval</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">inDat</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">shape</span><span class="p">(</span><span class="n">inDat</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">mat</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>
    <span class="n">X</span><span class="p">[:,</span> <span class="mi">1</span> <span class="p">:</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">inDat</span>
    <span class="k">return</span> <span class="nf">float</span><span class="p">(</span><span class="n">X</span> <span class="o">*</span> <span class="n">model</span><span class="p">)</span>


<span class="c1"># 预测函数
</span><span class="k">def</span> <span class="nf">treeForeCast</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">inData</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nf">isTree</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
        <span class="k">return</span> <span class="nf">modelTreeEval</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">inData</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">inData</span><span class="p">[</span><span class="n">tree</span><span class="p">[</span><span class="sh">"</span><span class="s">spInd</span><span class="sh">"</span><span class="p">]]</span> <span class="o">&gt;</span> <span class="n">tree</span><span class="p">[</span><span class="sh">"</span><span class="s">spVal</span><span class="sh">"</span><span class="p">]:</span>
        <span class="k">if</span> <span class="nf">isTree</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="sh">"</span><span class="s">left</span><span class="sh">"</span><span class="p">]):</span>
            <span class="k">return</span> <span class="nf">treeForeCast</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="sh">"</span><span class="s">left</span><span class="sh">"</span><span class="p">],</span> <span class="n">inData</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nf">modelTreeEval</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="sh">"</span><span class="s">left</span><span class="sh">"</span><span class="p">],</span> <span class="n">inData</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nf">isTree</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="sh">"</span><span class="s">right</span><span class="sh">"</span><span class="p">]):</span>
            <span class="k">return</span> <span class="nf">treeForeCast</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="sh">"</span><span class="s">right</span><span class="sh">"</span><span class="p">],</span> <span class="n">inData</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nf">modelTreeEval</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="sh">"</span><span class="s">right</span><span class="sh">"</span><span class="p">],</span> <span class="n">inData</span><span class="p">)</span>


<span class="c1"># 对测试数据集预测一系列结果, 用于做图
</span><span class="k">def</span> <span class="nf">createForeCast</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">testData</span><span class="p">):</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">testData</span><span class="p">)</span>
    <span class="n">yHat</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">mat</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">((</span><span class="n">m</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>  <span class="c1"># m是item个数
</span>        <span class="n">yHat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nf">treeForeCast</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="nf">mat</span><span class="p">(</span><span class="n">testData</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">yHat</span>


<span class="c1"># 绘图
</span><span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="n">dataSet</span><span class="p">,</span> <span class="n">tree</span><span class="p">):</span>
    <span class="n">plt</span><span class="p">.</span><span class="nf">scatter</span><span class="p">(</span><span class="n">dataSet</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">dataSet</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>  <span class="c1"># 在图中以点画收盘价
</span>    <span class="n">yHat</span> <span class="o">=</span> <span class="nf">createForeCast</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">dataSet</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="n">plt</span><span class="p">.</span><span class="nf">plot</span><span class="p">(</span><span class="n">dataSet</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">yHat</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="sh">"</span><span class="s">red</span><span class="sh">"</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="nf">show</span><span class="p">()</span>


<span class="c1"># 生成回归树, dataSet是数据, rate是误差下降, dur是叶节点的最小样本数
</span><span class="k">def</span> <span class="nf">createTree</span><span class="p">(</span><span class="n">dataSet</span><span class="p">,</span> <span class="n">rate</span><span class="p">,</span> <span class="n">dur</span><span class="p">):</span>
    <span class="c1"># 寻找最佳划分点, feat为切分点, val为值
</span>    <span class="n">feat</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="nf">chooseBestSplit</span><span class="p">(</span><span class="n">dataSet</span><span class="p">,</span> <span class="n">rate</span><span class="p">,</span> <span class="n">dur</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">feat</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">val</span>  <span class="c1"># 不再可分
</span>    <span class="n">retTree</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">retTree</span><span class="p">[</span><span class="sh">"</span><span class="s">spInd</span><span class="sh">"</span><span class="p">]</span> <span class="o">=</span> <span class="n">feat</span>
    <span class="n">retTree</span><span class="p">[</span><span class="sh">"</span><span class="s">spVal</span><span class="sh">"</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
    <span class="n">lSet</span><span class="p">,</span> <span class="n">rSet</span> <span class="o">=</span> <span class="nf">binSplitDataSet</span><span class="p">(</span><span class="n">dataSet</span><span class="p">,</span> <span class="n">feat</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>  <span class="c1"># 把数据切给左右两树
</span>    <span class="n">retTree</span><span class="p">[</span><span class="sh">"</span><span class="s">left</span><span class="sh">"</span><span class="p">]</span> <span class="o">=</span> <span class="nf">createTree</span><span class="p">(</span><span class="n">lSet</span><span class="p">,</span> <span class="n">rate</span><span class="p">,</span> <span class="n">dur</span><span class="p">)</span>
    <span class="n">retTree</span><span class="p">[</span><span class="sh">"</span><span class="s">right</span><span class="sh">"</span><span class="p">]</span> <span class="o">=</span> <span class="nf">createTree</span><span class="p">(</span><span class="n">rSet</span><span class="p">,</span> <span class="n">rate</span><span class="p">,</span> <span class="n">dur</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">retTree</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="sh">"</span><span class="s">__main__</span><span class="sh">"</span><span class="p">:</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">ts</span><span class="p">.</span><span class="nf">get_k_data</span><span class="p">(</span><span class="n">code</span><span class="o">=</span><span class="sh">"</span><span class="s">002230</span><span class="sh">"</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="sh">"</span><span class="s">2017-01-01</span><span class="sh">"</span><span class="p">)</span>  <span class="c1"># 科大讯飞今年的股票数据
</span>    <span class="n">e</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="nc">DataFrame</span><span class="p">()</span>
    <span class="n">e</span><span class="p">[</span><span class="sh">"</span><span class="s">idx</span><span class="sh">"</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">.</span><span class="n">index</span>  <span class="c1"># 用索引号保证顺序X轴
</span>    <span class="n">e</span><span class="p">[</span><span class="sh">"</span><span class="s">close</span><span class="sh">"</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="sh">"</span><span class="s">close</span><span class="sh">"</span><span class="p">]</span>  <span class="c1"># 用收盘价作为分类标准Y轴, 以Y轴高低划分X成段，并分段拟合
</span>    <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="nf">createTree</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">mat</span><span class="p">(</span><span class="n">arr</span><span class="p">),</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="nf">draw</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">tree</span><span class="p">)</span>
</code></pre></div></div>

<h1 id="分析">分析</h1>

<p>算法的拟合度和复杂度是使用步长, 误差下降和最小样本数控制的, 计算的时间跨度(一月/一年)也影响着程序运行时间.</p>

<p>例程中计算的是 <code class="language-plaintext highlighter-rouge">科大讯飞</code> 近一年来的股价趋势, 计算用时约十秒左右(我的机器速度还可以).</p>

<p>要计算所有的股票, 也需要不少时间. 所以具体实现时, 一方面可以利用当前价格和移动均线的相对位置过滤掉一些股票, 另一方面, 也可以将计算结果存储下来, 以避免对之前数据的重复计算.</p>]]></content><author><name>Zhigang Song</name></author><category term="time-sequence" /><category term="quant" /><category term="decision-tree" /><category term="linear-regression" /><summary type="html"><![CDATA[原文: 机器学习_用树回归方法画股票趋势线 本篇的主题是分段线性拟合, 也叫回归树, 是一种集成算法, 它同时使用了决策和线性回归的原理, 其中有两点不太容易理解, 一个是决策树中熵的概念, 一个是线性拟合时求参数的公式为什么是由矩阵乘法实现的. 如需详解, 请见前篇: 《机器学习_决策树与信息熵》 《机器学习_最小二乘法，线性回归与逻辑回归》 画出股票的趋势线 我们常在股票节目里看到这样的趋势线:]]></summary></entry><entry><title type="html">常见的时间序列趋势判别算法</title><link href="http://sidgwick.github.io/2023/09/15/time-sequence-trending-algorithm.html" rel="alternate" type="text/html" title="常见的时间序列趋势判别算法" /><published>2023-09-15T19:34:04+08:00</published><updated>2023-09-15T19:34:04+08:00</updated><id>http://sidgwick.github.io/2023/09/15/time-sequence-trending-algorithm</id><content type="html" xml:base="http://sidgwick.github.io/2023/09/15/time-sequence-trending-algorithm.html"><![CDATA[<p>本文介绍常见的时间序列趋势判别算法:</p>

<ol>
  <li>多项式拟合(斜率)</li>
  <li>Mann-Kendall 趋势检验检验</li>
  <li>Cox-stuart 趋势检验</li>
</ol>

<h1 id="多项式拟合最小二乘法">多项式拟合(最小二乘法)</h1>

<h2 id="基本原理">基本原理</h2>

<p>核心是使用最小二乘法见序列拟合成一条直线, 然后根据直线的斜率 <code class="language-plaintext highlighter-rouge">k</code> 判断序列的走势. 如果返回的是正数则正增长, 如果返回的是负数则为下降, 如果为 0 则表示没有趋势.</p>

<!--more-->

<p>本方法的<strong>优点</strong>是方法简单, 可解释性强. <strong>缺点</strong>是要求趋势是线性的, 当数去波动较大时, 无法准确拟合.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">trendline</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="n">order</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">index</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
    <span class="n">coeffs</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">polyfit</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nf">list</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">order</span><span class="p">)</span>
    <span class="n">slope</span> <span class="o">=</span> <span class="n">coeffs</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
    <span class="k">return</span> <span class="nf">float</span><span class="p">(</span><span class="n">slope</span><span class="p">)</span>


<span class="n">resultent</span> <span class="o">=</span> <span class="nf">trendline</span><span class="p">(</span><span class="n">List</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">resultent</span><span class="p">)</span>
</code></pre></div></div>

<p>该方法主要用到的函数是 <code class="language-plaintext highlighter-rouge">np.polyfit(x, y, deg, *args)</code>, 其中:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">deg</code> 为需要拟合函数的最高次数, 当 <code class="language-plaintext highlighter-rouge">deg = 0</code> 时, 式子是一个常数项, 即 $y = a_0$</li>
  <li><code class="language-plaintext highlighter-rouge">np.polyfit</code> 函数的返回值是拟合好之后的参数, 即 $a_n, a_{n-1}, …, a_0$</li>
</ol>

<p><code class="language-plaintext highlighter-rouge">np.polyfit</code> 的返回结果可以传递给 <code class="language-plaintext highlighter-rouge">np.ploy1d</code>, 这个函数会生成对应的多项式表达式.</p>

<p><img src="https://qiniu.iuwei.fun/blog/python/numpy/np_poly1d.jpg" alt="" /></p>

<h2 id="实验">实验</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">from</span> <span class="n">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>

<span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sh">'''</span><span class="s">原函数</span><span class="sh">'''</span>
    <span class="k">return</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="mi">4</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">3</span> <span class="o">-</span> <span class="mi">5</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>

<span class="k">def</span> <span class="nf">trendline</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="sh">'''</span><span class="s">拟合函数，输出参数</span><span class="sh">'''</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">polyfit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">deg</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="p">.</span><span class="nf">poly1d</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>


<span class="c1"># 生成 30 个时序坐标点 (x, y)，前 20 个点用于拟合，后 10 个点用于预测
</span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">30</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="nf">func</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">y1</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">randn</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1.5</span> <span class="c1"># 加上噪声
</span>
<span class="n">ff</span> <span class="o">=</span> <span class="nf">trendline</span><span class="p">(</span><span class="n">x</span><span class="p">[:</span><span class="mi">20</span><span class="p">],</span> <span class="n">y1</span><span class="p">[:</span><span class="mi">20</span><span class="p">],</span> <span class="n">n</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="n">pred</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">poly1d</span><span class="p">(</span><span class="n">ff</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>

<span class="c1"># 作图
</span><span class="n">plt</span><span class="p">.</span><span class="nf">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">7</span><span class="p">))</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">scatter</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="sh">'</span><span class="s">blue</span><span class="sh">'</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sh">"</span><span class="s">raw</span><span class="sh">"</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="sh">'</span><span class="s">yellow</span><span class="sh">'</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sh">'</span><span class="s">real</span><span class="sh">'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="sh">'</span><span class="s">red</span><span class="sh">'</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sh">'</span><span class="s">fit</span><span class="sh">'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">show</span><span class="p">()</span>
</code></pre></div></div>

<p>运行结果如下:</p>

<h1 id="cox-stuart-趋势检验">Cox-stuart 趋势检验</h1>

<h2 id="基本原理-1">基本原理</h2>

<p>Cox-Stuart 趋势检验过程直接考虑数据的变化趋势, 若数据有上升趋势, 那么排在后面的数据的值要比排在前面的数据的值显著的大, 反之若数据有下降趋势, 那么排在后面的数据的值要比排在前面的数据的值显著的小, 利用前后两个时期不同数据的差值正负来判断数据总的变化趋势.</p>

<h2 id="算法过程">算法过程</h2>

<p>假设 $n$ 个数据形成数据列 $X = [x_1, x_2, …, x_n]$,
取 $x_i$ 和 $x_{i+c}$ 组成一对 $(x_i, x_{i+c})$, 这里如果 $n$ 为偶数，则 $c=\frac{n}{2}$ ，如果 $n$ 是奇数，则 $c=\frac{(n+1)}{2}$, 当 $n$ 为偶数时，数据对共有 $n’=c$ 对, 而 $n$ 是奇数时, 共有 $n’=c-1$ 对.</p>

<p>用每一对的两元素差 $D_i = x_i − x_{i+c}$ 的符号来衡量增减, 令 $S+$ 为正的 $D_i$ 的数目, $S-$ 为负的 $D_i$ 的数目. 显然当正号太多时有下降趋势, 反之有增长趋势. 在没有趋势的零假设下他们因服从二项分布 $B(n’, 0.5)$.</p>

<p>用 $p(+)$ 表示取到正数的概率, 用 $p(-)$ 表示取到负数的概率, 这样我们就得到符号检验方法来检验序列是否存在趋势性.</p>

<p>本方法<strong>优点</strong>是可以不依赖趋势结构, 快速判断出趋势是否存在. <strong>缺点</strong>是未考虑数据的时序性, 仅仅只能通过符号检验来判断.</p>

<h2 id="实验-1">实验:</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">scipy.stats</span> <span class="k">as</span> <span class="n">stats</span>


<span class="k">def</span> <span class="nf">cos_stuart</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">xx</span> <span class="o">=</span> <span class="n">x</span>  <span class="c1"># 因为需要删除，所以复制一份
</span>    <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">del</span> <span class="n">xx</span><span class="p">[</span><span class="n">n</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">n</span> <span class="o">//</span> <span class="mi">2</span>

    <span class="c1"># 计算正负符号的数量
</span>    <span class="n">n_pos</span> <span class="o">=</span> <span class="n">n_neg</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># n_pos=S+  n_neg=S-
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="n">xx</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">c</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">diff</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">n_pos</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">n_neg</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">continue</span>

    <span class="n">num</span> <span class="o">=</span> <span class="n">n_pos</span> <span class="o">+</span> <span class="n">n_neg</span>
    <span class="n">k</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">n_pos</span><span class="p">,</span> <span class="n">n_neg</span><span class="p">)</span>  <span class="c1"># 求K值
</span>    <span class="n">p_value</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">stats</span><span class="p">.</span><span class="n">binom</span><span class="p">.</span><span class="nf">cdf</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>  <span class="c1"># 计算p_value
</span>    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">fall:{}, rise:{}, p-value:{}</span><span class="sh">"</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="n">n_neg</span><span class="p">,</span> <span class="n">n_pos</span><span class="p">,</span> <span class="n">p_value</span><span class="p">))</span>

    <span class="c1"># p_value&lt;0.05,零假设不成立
</span>    <span class="k">if</span> <span class="n">n_pos</span> <span class="o">&gt;</span> <span class="n">n_neg</span> <span class="ow">and</span> <span class="n">p_value</span> <span class="o">&lt;</span> <span class="mf">0.05</span><span class="p">:</span>
        <span class="k">return</span> <span class="sh">"</span><span class="s">increasing</span><span class="sh">"</span>
    <span class="k">elif</span> <span class="n">n_neg</span> <span class="o">&gt;</span> <span class="n">n_pos</span> <span class="ow">and</span> <span class="n">p_value</span> <span class="o">&lt;</span> <span class="mf">0.05</span><span class="p">:</span>
        <span class="k">return</span> <span class="sh">"</span><span class="s">decreasing</span><span class="sh">"</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="sh">"</span><span class="s">no trend</span><span class="sh">"</span>

<span class="n">x</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">20</span><span class="p">))</span>
<span class="nf">cos_stuart</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="c1">#&gt;&gt;&gt; 输出 &lt;&lt;&lt;
#&gt; fall:0, rise:9, p-value:0.00390625
#&gt; 'increasing'
</span></code></pre></div></div>

<h1 id="mann-kendall-趋势检验">Mann-Kendall 趋势检验</h1>

<h2 id="基本原理-2">基本原理</h2>

<p>使用 MK 算法检验时序数据大致趋势, 趋势分为无明显趋势(稳定), 趋势上升, 趋势下降.</p>

<p>MK 检验的基础:</p>

<ul>
  <li>当没有趋势时, 随时间获得的数据是独立同分布的, 数据随着时间不是连续相关的.</li>
  <li>所获得的时间序列上的数据代表了采样时的真实条件, 样本要具有代表性.</li>
  <li>MK 检验不要求数据是正态分布, 也不要求变化趋势是线性的.</li>
  <li>如果有缺失值或者值低于一个或多个检测限制, 是可以计算 MK 检测的, 但检测性能会受到不利影响.</li>
  <li>独立性假设要求样本之间的时间足够大, 这样在不同时间收集的测量值之间不存在相关性</li>
</ul>

<h2 id="算法过程没看懂">算法过程(没看懂)</h2>

<h3 id="第一部分-计算趋势">第一部分, 计算趋势</h3>

<ol>
  <li>设零假设 $H_0$ 没有单调趋势, $H_a$ 有单调趋势</li>
  <li>数据按照采集时间一次取出, 记为 $X = [x_1, x_2, x_3, …, x_n]$</li>
  <li>
    <p>确定所有 $C_n^2$ 个 $x_j - x_i$ 的差值函数 $Sign(x_j - x_i)$, $1 \le j \lt i \le n$, 函数定义如下:</p>

\[Sign(x_j - x_i) = \begin{cases}
   -1, &amp; x_j - x_i \lt 0 \\
   0, &amp; x_j - x_i = 0, 或者数据缺失 \\
   1, &amp; x_j - x_i \gt 0 \\
\end{cases}\]
  </li>
  <li>
    <p>求检验统计量</p>

\[S = \sum_{i=1}^{n-1} \sum_{j=i+1}^{n} Sign(x_j - x_i)\]

    <p>如果 $S$ 是一个正数, 那么后一部分的观测值相比之前的观测值会趋向于变大, 如果 $S$ 是一个负数, 那么后一部分的观测值相比之前的观测值会趋向于变小.</p>
  </li>
  <li>
    <p>如果 $n$ 比较小(比如小于 8), 依据 Gilbert (1987, page 209, Section 16.4.1)中所描述的程序, 要去概率表(Gilbert 1987, Table A18, page 272)里面查找 $S$, 这个表目前找不到了, 这里给出一个 $S$ 和 $Z$ 的关系式:</p>

\[Z = \frac{S}{\frac{n(n-1)}{2}}\]

    <p>如果此概率小于 $\alpha$ (认为没有趋势时的截止概率), 那就拒绝零假设, 认为趋势存在.
如果在概率表中找不到 $n$ (存在结数据(tied data values)会发生此情况), 就用表中远离 $0$ 的下一个值, 比如如果概率表中没有 $S=12$, 那么就用 $S=13$ 来处理也是一样的.</p>

    <p><img src="https://qiniu.iuwei.fun/blog/math/gilbert_appendix_table_a18.jpg" alt="" /></p>
  </li>
  <li>
    <p>当 $n \ge 8$ 时, 按照 Gilbert (1987, page 211, Section 16.4.2)中的程序, 统计量 $S$ 大致的服从正态分布, 方差通过以下方式计算</p>

    <p>如果数据中, 每个数字都是唯一的, 则方差</p>

\[Var(S)= \frac{n(n-1)(2n+5)}{18}\]

    <p>如果数据中数据存在不唯一, 则公式变为</p>

\[Var(S)= \frac{n(n-1)(2n+5) - \sum_{p=1}^{g} t_p(t_p-1)(2t_p+5)}{18}\]

    <p>其中, $p$ 为重复数据数量, $g$ 为唯一数数量(结组数), $t_p$ 为每个重复数重复的次数.</p>

    <p>当因为有或者未检测到而出现结时, $Var(S)$ 可以通过 Helsel(2005, p.191)中的结修正方法来修正.</p>
  </li>
  <li>
    <p>计算标准化后的检验统计量 Z 如下:</p>

\[Z_{MK} = \begin{cases}
 \frac{S-1}{\sqrt{V_{ar}(S)}}, &amp; S&gt;0 \\
 0, &amp; S=0 \\
 \frac{S+1}{\sqrt{V_{ar}(S)}}, &amp; S&lt;0 \\
\end{cases}\]
  </li>
  <li>
    <p>回到 $H_0$ 和 $H_a$ 假设</p>

    <blockquote>
      <p>什么是一型错误和二型错误</p>

      <ul>
        <li>一型错误: 原假设是正确的, 推翻了原假设造成的错误</li>
        <li>二型错误: 原假设是错误的, 没有推翻原假设造成的错误</li>
      </ul>
    </blockquote>

    <p>其一型错误率为 $\alpha$, $0 \lt \alpha \lt 0.5$(注意 $\alpha$ 是 MK 检验错误地拒绝了零假设时可容忍的概率, 即 MK 检验拒绝了零假设是错误的, 但这个事情发生概率是 $\alpha$, 我们可以容忍这个错误).</p>

    <ol>
      <li>
        <p>针对 $H_0$ 没有单调趋势, $H_a$ 有单调增趋势</p>

        <p>如果 $Z_{MK} \ge Z_{1 - \alpha}$, 就拒绝零假设 $H_0$, 接受替代假设 $H_a$. 其中 $Z_{1 - \alpha}$ 是标准正态分布的 $100(1-\alpha)^{th}$ 百分位(percentile, 不是很懂他说的这些是什么, 需要看一下参考文献). 这些百分位在许多统计书(比如 Gilbert 1987, Table A1, page 254)和统计软件包中都有提供.</p>
      </li>
      <li>
        <p>针对 $H_0$ 没有单调趋势, $H_a$ 有单调减趋势</p>

        <p>如果 $Z_{MK} \le - Z_{1 - \alpha}$, 就拒绝零假设 $H_0$, 接受替代假设 $H_a$.</p>
      </li>
      <li>
        <p>针对 $H_0$ 没有单调趋势, $H_a$ 有单调递增或递减趋势</p>

        <p>如果 $\lvert Z_{MK} \rvert \ge Z_{1 - \frac{\alpha}{2}} $, 就拒绝零假设 $H_0$, 接受替代假设 $H_a$.</p>
      </li>
    </ol>
  </li>
  <li>
    <p>最终得到错误率为 $\alpha$, $0 \lt \alpha \lt 0.5$, $\lvert Z_{MK} \rvert \ge Z_{1-\frac{\alpha}{2}}$, $Z_{1-\frac{\alpha}{2}}$ 为 $ppf(1-\frac{\alpha}{2})$(为什么是 $1 - \frac{\alpha}{2}$, 是因为概率为正态分布而且左右两边均存在, 且 $1-\frac{\alpha}{2}$ 为置信度)</p>

    <p>在双边趋势检验中, 对于给定的置信水平 $\alpha$ (显著性水平), 若 $\lvert Z \rvert \ge Z_{1 - \frac{\alpha}{2}}$, 则原假设 $H_0$ 是不可接受的, 即在置信水平 $\alpha$ (显著性检验水平)上, 时间序列数据存在明显的上升或下降趋势. $Z$ 为正值表示上升趋势, 负值表示减少趋势, $Z$ 的绝对值在大于等于 $1.645, 1.96, 2.576$ 时表示分别通过了置信度 $90\%, 95\%, 99\%$ 的显著性检验.</p>

    <p>计算过程: 以 $ \alpha = 0.1$ 为例, $Z_{1-\frac{\alpha}{2}} = Z_{0.95}$, 查询标准正态分布表 $Z_{0.95} = 1.645$, 故 $Z \ge 1.645$ 时通过 $90\%$ 的显著性检验, $H_0$ 假设不成立, $Z \gt 0$, 序列存在上升趋势.</p>
  </li>
  <li>
    <p>衡量趋势大小的指标, 用倾斜度 $\beta$ 表示为:</p>

\[\beta = median(\frac{x_j - x_i}{j - i}) \quad \forall \space 1 \lt i \lt j \lt n\]
  </li>
  <li>
    <p>$P$ 值计算验证(可选)</p>

\[P = 2(1-cdf(\lvert Z_{MK} \rvert))\]
  </li>
</ol>

<h3 id="第二部分-查找突变点">第二部分, 查找突变点</h3>

<ol>
  <li>
    <p>设 $S_k$ 表示 $X$ 中的第 $j$ 个样本 $x_j \gt x_i (1 \le i \le j)$ 的累计数, 定义统计量 $S_k$:</p>

\[S_k = \sum_{j=1}^k r_j \quad (r_j = \begin{cases}
 1 &amp; x_j \gt x_i \\
 0 &amp; x_j \le x_i \\
\end{cases}, \quad i=1,2,...,j;k=1,2,....n)\]
  </li>
  <li>
    <p>在时间序列随机独立的假定下, $S_k$ 的均值为:</p>

\[E[S_k] = \frac{k(k-1)}{4}\]

    <p>方差为</p>

\[Var[S_k] = \frac{k(k-1)(2k+5)}{72} \quad 1 \le k \le n\]
  </li>
  <li>
    <p>将 $S_k$ 标准化:</p>

    <p>其中 $UF_1=0$, 给定显著性水平 $\alpha$, 若 $\lvert UF_k \rvert \gt U_{\alpha}$, 则表明序列存在明显的趋势变化. 所有 $UF_k$ 可组成一条曲线, 将此方法引用到反序列, 将反序列 $x_n, x_{n-1}, …, x_1$ 表示为 $x’_1, x’_2, …, x’_n$. $j$ 表示第 $j$ 个样本 $x_j$ 大于 $x_i (j \le i \le n)$ 的累计数. 当 $j’ = n+1-j$ 时, $j = r’j$, 则反序列的 $UB_k$ 为:</p>

\[UB_k = -UF_k \quad k'=n+1-j \quad j,j'=1,2,...,n...\]

    <p>其中 $UB_1=0$, $UB_k$ 不是简单的等于 $UF_k$ 负值, 而是进行了倒置再取负, 此处 $UF_k$ 是根据反序列算出来的.</p>

    <p>给定显著性水平, 若 $\alpha =0.05$, 那么临界值为 $\pm 1.96$, 绘制 $UF_k$ 和 $UB_k$ 曲线图和 $\pm 1.96$ 俩条直线再一张图上, 若 $UF_k$ 得值大于 $0$, 则表明序列呈现上升趋势, 小于 $0$ 则表明呈现下降趋势, 当它们超过临界直线时, 表明上升或下降趋势显著. 超过临界线的范围确定为出现突变的时间区域. 如果 $UF_k$ 和 $UB_k$ 两条曲线出现交点, 且交点在临界线内, 那么交点对应的时刻便是突变开始的时间.</p>
  </li>
</ol>

<p>优点: 功能强大, 不需要样本遵从一定的分布, 部分数据缺失不会对结果造成影响, 不受少数异常值的干扰, 适用性强. 不但可以检验时间序列的变化趋势, 还可以检验时间序列是否发生了突变.</p>

<p>缺点: 暂未发现, 待后续补充.</p>

<p>主要参考资料:</p>

<ul>
  <li><a href="https://blog.csdn.net/aaakirito/article/details/116941586">CSDN - 多项式拟合(最小二乘法)</a></li>
  <li><a href="https://blog.csdn.net/aaakirito/article/details/116646521">CSDN - Cox-stuart 趋势检验</a></li>
  <li><a href="https://blog.csdn.net/aaakirito/article/details/116600294">CSDN - MK 趋势检验</a></li>
  <li><a href="https://www.jianshu.com/p/eae362946ea9">简书 - Mann-Kendall 趋势检验算法</a></li>
  <li><a href="https://zhuanlan.zhihu.com/p/339202638">知乎 - Mann-Kendall’ test 曼－肯德尔趋势检验法</a></li>
  <li><a href="https://www.osti.gov/biblio/7037501">Gilbert, Richard O - Statistical methods for environmental pollution monitoring</a></li>
  <li><a href="https://vsp.pnnl.gov/help/vsample/design_trend_mann_kendall.htm">PNNL - Mann-Kendall Test For Monotonic Trend</a></li>
</ul>

<p>更多资料:</p>

<ul>
  <li><a href="https://www.cnblogs.com/lsm-boke/p/11746274.html">机器学习–线性回归算法的原理及优缺点</a></li>
  <li><a href="https://zhuanlan.zhihu.com/p/38128785/">知乎 最小二乘法（least sqaure method）</a></li>
  <li><a href="https://zhuanlan.zhihu.com/p/53056358">知乎 多项式曲线拟合</a></li>
  <li><a href="https://zhuanlan.zhihu.com/p/112703276">知乎 时序数据常用趋势检测方法</a></li>
  <li><a href="https://wenku.baidu.com/view/cec731b981c758f5f61f6760.html">百度文库 Cox-Stuart 趋势检验</a></li>
  <li><a href="https://blog.csdn.net/liuchengzimozigreat/article/details/87931248">python 中的 Mann-Kendall 单调趋势检验–及原理说明</a></li>
  <li><a href="https://blog.csdn.net/shanchuan2012/article/details/52901758/">norm.ppf() norm.cdf() 【Matlab】正态分布常用函数</a></li>
  <li><a href="https://blog.csdn.net/weixin_43850016/article/details/106457201">序列的趋势存在性检验：Cox-Stuart test 和 Mann-Kendall test</a></li>
  <li><a href="https://blog.csdn.net/qq_34356768/article/details/106559399">时间序列数据趋势分析 Cox-Stuart、Mann-Kendall、Dickey-Fuller</a></li>
</ul>]]></content><author><name>Zhigang Song</name></author><category term="time-sequence" /><category term="quant" /><summary type="html"><![CDATA[本文介绍常见的时间序列趋势判别算法: 多项式拟合(斜率) Mann-Kendall 趋势检验检验 Cox-stuart 趋势检验 多项式拟合(最小二乘法) 基本原理 核心是使用最小二乘法见序列拟合成一条直线, 然后根据直线的斜率 k 判断序列的走势. 如果返回的是正数则正增长, 如果返回的是负数则为下降, 如果为 0 则表示没有趋势.]]></summary></entry><entry><title type="html">Monkey Patching in Go</title><link href="http://sidgwick.github.io/2023/06/29/monkey-patching-in-go.html" rel="alternate" type="text/html" title="Monkey Patching in Go" /><published>2023-06-29T22:28:04+08:00</published><updated>2023-06-29T22:28:04+08:00</updated><id>http://sidgwick.github.io/2023/06/29/monkey-patching-in-go</id><content type="html" xml:base="http://sidgwick.github.io/2023/06/29/monkey-patching-in-go.html"><![CDATA[<blockquote>
  <p>本文是 <a href="https://bou.ke/blog/monkey-patching-in-go/">Monkey Patching in Go</a> 的阅读理解.</p>
</blockquote>

<h1 id="原文-monkey-patching-in-go">原文 Monkey Patching in Go</h1>

<p>Many people think that monkey patching is something that is restricted to dynamic languages like Ruby and Python. That is not true however, as computers are just dumb machines and we can always make them do what we want! Let’s look at how Go functions work and how we can modify them at runtime. This article will use a lot of Intel assembly syntax, so I’m assuming you can read it already or are using a <a href="https://software.intel.com/en-us/articles/introduction-to-x64-assembly">reference</a> while reading.</p>

<!--more-->

<p>If you’re not interested in how it works and you just want to do monkey patching, then you can find the library <a href="https://github.com/bouk/monkey">here</a>.</p>

<p>Let’s look at what the following code produces when disassembled:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">func</span> <span class="n">axx</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="m">1</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">axx</span><span class="p">())</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>Samples should be built with <code class="language-plaintext highlighter-rouge">go build -gcflags='-N -l'</code> to disable inlining. For this article I assume your architecture is 64-bits and that you’re using a unix-based operating system like Mac OSX or a Linux variant.
编译参数说明可以参考: <a href="https://www.bwangel.me/2022/01/12/go_gcflags/">Go gcflags/ldflags 的说明</a></p>
</blockquote>

<p>When compiled and looked at through Hopper, the above code will produce this assembly code:</p>

<p>I will be referring to the addresses of the various instructions displayed on the left side of the screen.</p>

<p><img src="https://bou.ke/images/hopper-1.png" alt="" /></p>

<p>Our code starts in procedure main.main, where instructions 0x2010 to 0x2026 set up the stack. You can read more about that here, I will be ignoring that code for the rest of the article.</p>

<p>Line 0x202a is the call to function main.a at line 0x2000 which simply moves 0x1 onto the stack and returns. Lines 0x202f to 0x2037 then pass that value on to runtime.printint.</p>

<p>Simple enough! Now let’s take a look at how function values are implemented in Go.</p>

<h2 id="how-function-values-work-in-go">How function values work in Go</h2>

<p>Consider the following code:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"fmt"</span>
	<span class="s">"unsafe"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">a</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="m">1</span> <span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">f</span> <span class="o">:=</span> <span class="n">a</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"0x%x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f</span><span class="p">)))</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>Go 世界中的函数是一等公民</p>
</blockquote>

<p>What I’m doing on line 11 is assigning a to f, which means that doing f() will now call a. Then I use the unsafe Go package to directly read out the value stored in f. If you come from a C background you might expect f to simply be a function pointer to a and thus this code to print out 0x2000 (the location of main.a as we saw above). When I run this on my machine I get 0x102c38, which is an address not even close to our code! When disassembled, this is what happens on line 11 above:</p>

<p><img src="https://bou.ke/images/hopper-2.png" alt="" /></p>

<p>This references something called main.a.f, and when we look at that location, we see this:</p>

<p><img src="https://bou.ke/images/hopper-3.png" alt="" /></p>

<p>Aha! main.a.f is at 0x102c38 and contains 0x2000, which is the location of main.a. It seems f isn’t a pointer to a function, but a pointer to a pointer to a function. Let’s modify the code to compensate for that.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"fmt"</span>
	<span class="s">"unsafe"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">a</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="m">1</span> <span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">f</span> <span class="o">:=</span> <span class="n">a</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"0x%x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">**</span><span class="p">(</span><span class="o">**</span><span class="kt">uintptr</span><span class="p">)(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f</span><span class="p">)))</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>胖指针!!!</p>
</blockquote>

<p>This will now print 0x2000, as expected. We can find a clue as to why this is implemented as it is here. Go function values can contain extra information, which is how closures and bound instance methods are implemented.</p>

<p>Let’s look at how calling a function value works. I’ll change the code to call f after assigning it.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">func</span> <span class="n">a</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="m">1</span> <span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">f</span> <span class="o">:=</span> <span class="n">a</span>
	<span class="n">f</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<p>When we disassemble this we get the following:</p>

<p><img src="https://bou.ke/images/hopper-4.png" alt="" /></p>

<p>main.a.f gets loaded into rdx, then whatever rdx points at gets loaded into rbx, which then gets called. The address of the function value always gets loaded into rdx, which the code being called can use to load any extra information it might need. This extra information is a pointer to the instance for a bound instance method and the closure for an anonymous function. I advise you to take out a disassembler and dive deeper if you want to know more!</p>

<p>Let’s use our newly gained knowledge to implement monkeypatching in Go.</p>

<h2 id="replacing-a-function-at-runtime">Replacing a function at runtime</h2>

<p>What we want to achieve is to have the following code print out 2:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">func</span> <span class="n">a</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="m">1</span> <span class="p">}</span>
<span class="k">func</span> <span class="n">b</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="m">2</span> <span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">replace</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
	<span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">())</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Now how do we implement replace? We need to modify function a to jump to b’s code instead of executing its own body. Essentialy, we need to replace it with this, which loads the function value of b into rdx and then jumps to the location pointed to by rdx.</p>

<div class="language-as highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">mov</span> <span class="nx">rdx</span><span class="p">,</span> <span class="nx">main</span><span class="p">.</span><span class="nx">b</span><span class="p">.</span><span class="nx">f</span> <span class="o">;</span> <span class="mi">48</span> <span class="nx">C7</span> <span class="nx">C2</span> <span class="p">??</span> <span class="p">??</span> <span class="p">??</span> <span class="p">??</span>
<span class="nx">jmp</span> <span class="p">[</span><span class="nx">rdx</span><span class="p">]</span> <span class="o">;</span> <span class="nx">FF</span> <span class="mi">22</span>
</code></pre></div></div>

<p>I’ve put the corresponding machine code that those lines generate when assembled next to it (you can easily play around with assembly using an online assembler like <a href="https://defuse.ca/online-x86-assembler.htm">this</a>). Writing a function that will generate this code is now straightforward, and looks like this:</p>

<blockquote>
  <p>关于这段汇编的解释, 实际上这是作者使用了两个汇编指令(就是上面的 <code class="language-plaintext highlighter-rouge">mov</code> 和 <code class="language-plaintext highlighter-rouge">jmp</code>).</p>

  <p>假如说我们想把 <code class="language-plaintext highlighter-rouge">a()</code> 调用替换为 <code class="language-plaintext highlighter-rouge">b()</code>, 而且 <code class="language-plaintext highlighter-rouge">b</code> 函数在生成的可执行文件中的内存位置为 <code class="language-plaintext highlighter-rouge">0x01020304</code>, 那么, 需要做的就是生成下面这样的机器码(后面是对应的汇编指令):</p>

  <pre><code class="language-asm">9:	48 c7 c2 04 03 02 01 	mov    $0x01020304,%rdx
10:	ff 22                	jmpq   *(%rdx)
</code></pre>

  <p>只需要把这段机器码替换到原始函数的机器码开始位置, 就能实现调用 <code class="language-plaintext highlighter-rouge">a</code> 的时候跳转到 <code class="language-plaintext highlighter-rouge">b</code>. 从原理上说, 我们还是调用的 <code class="language-plaintext highlighter-rouge">a</code> 函数, 不过在 <code class="language-plaintext highlighter-rouge">a</code> 函数的开头现在有个跳转指令, 直接跳转到了 <code class="language-plaintext highlighter-rouge">b</code> 函数的位置执行, 执行完成之后由 <code class="language-plaintext highlighter-rouge">b</code> 函数里面的 <code class="language-plaintext highlighter-rouge">ret</code> 指令直接返回到 <code class="language-plaintext highlighter-rouge">a</code> 的调用者的下一条指令继续执行. 函数参数和返回值是依赖栈帧传递的, 这里替换之后不会影响栈, 因此也不会影响参数和返回值.</p>

  <p><code class="language-plaintext highlighter-rouge">assembleJump</code> 函数就是用来生成这种机器码的.</p>
</blockquote>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="s">"unsafe"</span>

<span class="k">func</span> <span class="n">assembleJump</span><span class="p">(</span><span class="n">f</span> <span class="k">func</span><span class="p">()</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
	<span class="n">funcVal</span> <span class="o">:=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f</span><span class="p">))</span>
	<span class="k">return</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">{</span>
		<span class="m">0x48</span><span class="p">,</span> <span class="m">0xC7</span><span class="p">,</span> <span class="m">0xC2</span><span class="p">,</span>
		<span class="kt">byte</span><span class="p">(</span><span class="n">funcval</span> <span class="o">&gt;&gt;</span> <span class="m">0</span><span class="p">),</span>
		<span class="kt">byte</span><span class="p">(</span><span class="n">funcval</span> <span class="o">&gt;&gt;</span> <span class="m">8</span><span class="p">),</span>
		<span class="kt">byte</span><span class="p">(</span><span class="n">funcval</span> <span class="o">&gt;&gt;</span> <span class="m">16</span><span class="p">),</span>
		<span class="kt">byte</span><span class="p">(</span><span class="n">funcval</span> <span class="o">&gt;&gt;</span> <span class="m">24</span><span class="p">),</span> <span class="c">// MOV rdx, funcVal</span>
		<span class="m">0xFF</span><span class="p">,</span> <span class="m">0x22</span><span class="p">,</span>          <span class="c">// JMP [rdx]</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We now have everything we need to replace a’s function body with a jump to b! The following code attempts to copy the machine code directly to the location of the function body.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"syscall"</span>
	<span class="s">"unsafe"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">a</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="m">1</span> <span class="p">}</span>
<span class="k">func</span> <span class="n">b</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="m">2</span> <span class="p">}</span>

<span class="c">// 这里获取运行时代码段中 `b` 代表的函数指针的内存区域</span>
<span class="c">// 通过覆写这块区域, 就可以实现函数指针指向偷天换日的效果</span>
<span class="k">func</span> <span class="n">rawMemoryAccess</span><span class="p">(</span><span class="n">b</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="m">0xFF</span><span class="p">]</span><span class="kt">byte</span><span class="p">)(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="n">b</span><span class="p">)))[</span><span class="o">:</span><span class="p">]</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">assembleJump</span><span class="p">(</span><span class="n">f</span> <span class="k">func</span><span class="p">()</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
	<span class="n">funcVal</span> <span class="o">:=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f</span><span class="p">))</span>
	<span class="k">return</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">{</span>
		<span class="m">0x48</span><span class="p">,</span> <span class="m">0xC7</span><span class="p">,</span> <span class="m">0xC2</span><span class="p">,</span>
		<span class="kt">byte</span><span class="p">(</span><span class="n">funcVal</span> <span class="o">&gt;&gt;</span> <span class="m">0</span><span class="p">),</span>
		<span class="kt">byte</span><span class="p">(</span><span class="n">funcVal</span> <span class="o">&gt;&gt;</span> <span class="m">8</span><span class="p">),</span>
		<span class="kt">byte</span><span class="p">(</span><span class="n">funcVal</span> <span class="o">&gt;&gt;</span> <span class="m">16</span><span class="p">),</span>
		<span class="kt">byte</span><span class="p">(</span><span class="n">funcVal</span> <span class="o">&gt;&gt;</span> <span class="m">24</span><span class="p">),</span> <span class="c">// MOV rdx, funcVal</span>
		<span class="m">0xFF</span><span class="p">,</span> <span class="m">0x22</span><span class="p">,</span> <span class="c">// JMP [rdx]</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">replace</span><span class="p">(</span><span class="n">orig</span><span class="p">,</span> <span class="n">replacement</span> <span class="k">func</span><span class="p">()</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">bytes</span> <span class="o">:=</span> <span class="n">assembleJump</span><span class="p">(</span><span class="n">replacement</span><span class="p">)</span>
	<span class="n">functionLocation</span> <span class="o">:=</span> <span class="o">**</span><span class="p">(</span><span class="o">**</span><span class="kt">uintptr</span><span class="p">)(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">orig</span><span class="p">))</span>
	<span class="n">window</span> <span class="o">:=</span> <span class="n">rawMemoryAccess</span><span class="p">(</span><span class="n">functionLocation</span><span class="p">)</span>
	<span class="nb">copy</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">replace</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
	<span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">())</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Running this code does not work however, and will result in a segmentation fault. This is because the loaded binary is not writable by default. We can use the mprotect syscall to disable this protection, and this final version of the code does exactly that, resulting in function a being replaced by function b, and <code class="language-plaintext highlighter-rouge">2</code> being printed.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"syscall"</span>
	<span class="s">"unsafe"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">a</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="m">1</span> <span class="p">}</span>
<span class="k">func</span> <span class="n">b</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="m">2</span> <span class="p">}</span>

<span class="k">func</span> <span class="n">getPage</span><span class="p">(</span><span class="n">p</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="m">0xFFFFFF</span><span class="p">]</span><span class="kt">byte</span><span class="p">)(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="n">p</span> <span class="o">&amp;</span> <span class="o">^</span><span class="kt">uintptr</span><span class="p">(</span><span class="n">syscall</span><span class="o">.</span><span class="n">Getpagesize</span><span class="p">()</span><span class="o">-</span><span class="m">1</span><span class="p">))))[</span><span class="o">:</span><span class="n">syscall</span><span class="o">.</span><span class="n">Getpagesize</span><span class="p">()]</span> <span class="c">// 拷贝一页 16Kb</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">rawMemoryAccess</span><span class="p">(</span><span class="n">b</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="m">0xFF</span><span class="p">]</span><span class="kt">byte</span><span class="p">)(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="n">b</span><span class="p">)))[</span><span class="o">:</span><span class="p">]</span> <span class="c">// 拷贝 255 个内存单元出去, 实际上只需要操作 9 个, 这里拷贝的数量大于 9 个就行</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">assembleJump</span><span class="p">(</span><span class="n">f</span> <span class="k">func</span><span class="p">()</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
	<span class="n">funcVal</span> <span class="o">:=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f</span><span class="p">))</span>
	<span class="k">return</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">{</span>
		<span class="m">0x48</span><span class="p">,</span> <span class="m">0xC7</span><span class="p">,</span> <span class="m">0xC2</span><span class="p">,</span>
		<span class="kt">byte</span><span class="p">(</span><span class="n">funcVal</span> <span class="o">&gt;&gt;</span> <span class="m">0</span><span class="p">),</span>
		<span class="kt">byte</span><span class="p">(</span><span class="n">funcVal</span> <span class="o">&gt;&gt;</span> <span class="m">8</span><span class="p">),</span>
		<span class="kt">byte</span><span class="p">(</span><span class="n">funcVal</span> <span class="o">&gt;&gt;</span> <span class="m">16</span><span class="p">),</span>
		<span class="kt">byte</span><span class="p">(</span><span class="n">funcVal</span> <span class="o">&gt;&gt;</span> <span class="m">24</span><span class="p">),</span> <span class="c">// MOV rdx, funcVal</span>
		<span class="m">0xFF</span><span class="p">,</span> <span class="m">0x22</span><span class="p">,</span> <span class="c">// JMP rdx</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">replace</span><span class="p">(</span><span class="n">orig</span><span class="p">,</span> <span class="n">replacement</span> <span class="k">func</span><span class="p">()</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">bytes</span> <span class="o">:=</span> <span class="n">assembleJump</span><span class="p">(</span><span class="n">replacement</span><span class="p">)</span>
	<span class="n">functionLocation</span> <span class="o">:=</span> <span class="o">**</span><span class="p">(</span><span class="o">**</span><span class="kt">uintptr</span><span class="p">)(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">orig</span><span class="p">))</span>
	<span class="n">window</span> <span class="o">:=</span> <span class="n">rawMemoryAccess</span><span class="p">(</span><span class="n">functionLocation</span><span class="p">)</span>
	<span class="n">page</span> <span class="o">:=</span> <span class="n">getPage</span><span class="p">(</span><span class="n">functionLocation</span><span class="p">)</span>
	<span class="n">syscall</span><span class="o">.</span><span class="n">Mprotect</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">syscall</span><span class="o">.</span><span class="n">PROT_READ</span><span class="o">|</span><span class="n">syscall</span><span class="o">.</span><span class="n">PROT_WRITE</span><span class="o">|</span><span class="n">syscall</span><span class="o">.</span><span class="n">PROT_EXEC</span><span class="p">)</span>
	<span class="nb">copy</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">replace</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
	<span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">())</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="wrapping-it-up-in-a-nice-library">Wrapping it up in a nice library</h2>

<p>I took the above code and put it in an easy to use library. It supports 32 bit, reversing patches, and patching instance methods. I wrote a couple of examples and put those in the README.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Where there’s a will there’s a way! It’s possible for a program to modify itself at runtime, which allows us to implement cool tricks like monkey patching.</p>

<p>I hope you got something useful out of this blogpost, I know I had fun making it!</p>

<h1 id="个人补充">个人补充</h1>

<blockquote>
  <p>这块我在研究上面的时候的实验尝试, 无论理解/不理解 Go 的汇编相关的东西, 对上文的阅读是没有影响的, 因此这部分 <strong>不用看</strong></p>
</blockquote>

<p>本文中用到的编译/汇编, 使用下面的指令完成:</p>

<p>编译为目标文件</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">&gt;</span><span class="w"> </span>go tool compile <span class="nt">-N</span> <span class="nt">-l</span> main.go
</code></pre></div></div>

<p>目标文件反汇编</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">&gt;</span><span class="w"> </span>go tool objdump <span class="nt">-gnu</span> main.o
</code></pre></div></div>

<div class="language-as highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">TEXT</span> <span class="o">%</span><span class="mi">22</span><span class="o">%</span><span class="mi">22</span><span class="p">.</span><span class="nx">axx</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span> <span class="nx">gofile</span><span class="p">..</span><span class="o">/</span><span class="nx">root</span><span class="o">/</span><span class="nx">xxx</span><span class="o">/</span><span class="nx">main</span><span class="p">.</span><span class="nx">go</span>
  <span class="nx">main</span><span class="p">.</span><span class="nx">go</span><span class="o">:</span><span class="mi">3</span>		<span class="mh">0x428</span>			<span class="mi">48</span><span class="nx">c744240800000000</span>	<span class="nx">MOVQ</span> <span class="nx">$0x0</span><span class="p">,</span> <span class="mh">0x8</span><span class="p">(</span><span class="nx">SP</span><span class="p">)</span>                   <span class="c1">// movq $0x0,0x8(%rsp)</span>
  <span class="nx">main</span><span class="p">.</span><span class="nx">go</span><span class="o">:</span><span class="mi">4</span>		<span class="mh">0x431</span>			<span class="mi">48</span><span class="nx">c744240801000000</span>	<span class="nx">MOVQ</span> <span class="nx">$0x1</span><span class="p">,</span> <span class="mh">0x8</span><span class="p">(</span><span class="nx">SP</span><span class="p">)</span>                   <span class="c1">// movq $0x1,0x8(%rsp)</span>
  <span class="nx">main</span><span class="p">.</span><span class="nx">go</span><span class="o">:</span><span class="mi">4</span>		<span class="mh">0x43a</span>			<span class="nx">c3</span>			        <span class="nx">RET</span>                                  <span class="c1">// retq</span>

<span class="nx">TEXT</span> <span class="o">%</span><span class="mi">22</span><span class="o">%</span><span class="mi">22</span><span class="p">.</span><span class="nx">main</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span> <span class="nx">gofile</span><span class="p">..</span><span class="o">/</span><span class="nx">root</span><span class="o">/</span><span class="nx">xxx</span><span class="o">/</span><span class="nx">main</span><span class="p">.</span><span class="nx">go</span>
  <span class="nx">main</span><span class="p">.</span><span class="nx">go</span><span class="o">:</span><span class="mi">7</span>		<span class="mh">0x43b</span>			<span class="mi">64488</span><span class="nx">b0c2500000000</span>	<span class="nx">MOVQ</span> <span class="nx">FS</span><span class="o">:</span><span class="mi">0</span><span class="p">,</span> <span class="nx">CX</span>                    <span class="c1">// mov %fs:,%rcx		[5:9]R_TLS_LE</span>
  <span class="nx">main</span><span class="p">.</span><span class="nx">go</span><span class="o">:</span><span class="mi">7</span>		<span class="mh">0x444</span>			<span class="mi">483</span><span class="nx">b6110</span>		<span class="nx">CMPQ</span> <span class="mh">0x10</span><span class="p">(</span><span class="nx">CX</span><span class="p">),</span> <span class="nx">SP</span>                    <span class="c1">// cmp 0x10(%rcx),%rsp</span>
  <span class="nx">main</span><span class="p">.</span><span class="nx">go</span><span class="o">:</span><span class="mi">7</span>		<span class="mh">0x448</span>			<span class="mi">7645</span>			<span class="nx">JBE</span> <span class="mh">0x48f</span>                            <span class="c1">// jbe 0x48f</span>
  <span class="nx">main</span><span class="p">.</span><span class="nx">go</span><span class="o">:</span><span class="mi">7</span>		<span class="mh">0x44a</span>			<span class="mi">4883</span><span class="nx">ec18</span>		<span class="nx">SUBQ</span> <span class="nx">$0x18</span><span class="p">,</span> <span class="nx">SP</span>                       <span class="c1">// sub $0x18,%rsp</span>
  <span class="nx">main</span><span class="p">.</span><span class="nx">go</span><span class="o">:</span><span class="mi">7</span>		<span class="mh">0x44e</span>			<span class="mi">48896</span><span class="nx">c2410</span>		<span class="nx">MOVQ</span> <span class="nx">BP</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">(</span><span class="nx">SP</span><span class="p">)</span>                    <span class="c1">// mov %rbp,0x10(%rsp)</span>
  <span class="nx">main</span><span class="p">.</span><span class="nx">go</span><span class="o">:</span><span class="mi">7</span>		<span class="mh">0x453</span>			<span class="mi">488</span><span class="nx">d6c2410</span>		<span class="nx">LEAQ</span> <span class="mh">0x10</span><span class="p">(</span><span class="nx">SP</span><span class="p">),</span> <span class="nx">BP</span>                    <span class="c1">// lea 0x10(%rsp),%rbp</span>
  <span class="nx">main</span><span class="p">.</span><span class="nx">go</span><span class="o">:</span><span class="mi">8</span>		<span class="mh">0x458</span>			<span class="mi">0</span><span class="nx">f1f00</span>			<span class="nx">NOPL</span> <span class="mi">0</span><span class="p">(</span><span class="nx">AX</span><span class="p">)</span>                           <span class="c1">// nopl (%rax)</span>
  <span class="nx">main</span><span class="p">.</span><span class="nx">go</span><span class="o">:</span><span class="mi">8</span>		<span class="mh">0x45b</span>			<span class="nx">e800000000</span>		<span class="nx">CALL</span> <span class="mh">0x460</span>                           <span class="c1">// callq 0x460		[1:5]R_CALL:"".axx</span>
  <span class="nx">main</span><span class="p">.</span><span class="nx">go</span><span class="o">:</span><span class="mi">8</span>		<span class="mh">0x460</span>			<span class="mi">488</span><span class="nx">b0424</span>		<span class="nx">MOVQ</span> <span class="mi">0</span><span class="p">(</span><span class="nx">SP</span><span class="p">),</span> <span class="nx">AX</span>                       <span class="c1">// mov (%rsp),%rax</span>
  <span class="nx">main</span><span class="p">.</span><span class="nx">go</span><span class="o">:</span><span class="mi">8</span>		<span class="mh">0x464</span>			<span class="mi">4889442408</span>		<span class="nx">MOVQ</span> <span class="nx">AX</span><span class="p">,</span> <span class="mh">0x8</span><span class="p">(</span><span class="nx">SP</span><span class="p">)</span>                     <span class="c1">// mov %rax,0x8(%rsp)</span>
  <span class="nx">main</span><span class="p">.</span><span class="nx">go</span><span class="o">:</span><span class="mi">8</span>		<span class="mh">0x469</span>			<span class="nx">e800000000</span>		<span class="nx">CALL</span> <span class="mh">0x46e</span>                           <span class="c1">// callq 0x46e		[1:5]R_CALL:runtime.printlock</span>
  <span class="nx">main</span><span class="p">.</span><span class="nx">go</span><span class="o">:</span><span class="mi">8</span>		<span class="mh">0x46e</span>			<span class="mi">488</span><span class="nx">b442408</span>		<span class="nx">MOVQ</span> <span class="mh">0x8</span><span class="p">(</span><span class="nx">SP</span><span class="p">),</span> <span class="nx">AX</span>                     <span class="c1">// mov 0x8(%rsp),%rax</span>
  <span class="nx">main</span><span class="p">.</span><span class="nx">go</span><span class="o">:</span><span class="mi">8</span>		<span class="mh">0x473</span>			<span class="mi">48890424</span>		<span class="nx">MOVQ</span> <span class="nx">AX</span><span class="p">,</span> <span class="mi">0</span><span class="p">(</span><span class="nx">SP</span><span class="p">)</span>                       <span class="c1">// mov %rax,(%rsp)</span>
  <span class="nx">main</span><span class="p">.</span><span class="nx">go</span><span class="o">:</span><span class="mi">8</span>		<span class="mh">0x477</span>			<span class="mi">0</span><span class="nx">f1f4000</span>		<span class="nx">NOPL</span> <span class="mi">0</span><span class="p">(</span><span class="nx">AX</span><span class="p">)</span>                           <span class="c1">// nopl (%rax)</span>
  <span class="nx">main</span><span class="p">.</span><span class="nx">go</span><span class="o">:</span><span class="mi">8</span>		<span class="mh">0x47b</span>			<span class="nx">e800000000</span>		<span class="nx">CALL</span> <span class="mh">0x480</span>                           <span class="c1">// callq 0x480		[1:5]R_CALL:runtime.printint</span>
  <span class="nx">main</span><span class="p">.</span><span class="nx">go</span><span class="o">:</span><span class="mi">8</span>		<span class="mh">0x480</span>			<span class="nx">e800000000</span>		<span class="nx">CALL</span> <span class="mh">0x485</span>                           <span class="c1">// callq 0x485		[1:5]R_CALL:runtime.printunlock</span>
  <span class="nx">main</span><span class="p">.</span><span class="nx">go</span><span class="o">:</span><span class="mi">9</span>		<span class="mh">0x485</span>			<span class="mi">488</span><span class="nx">b6c2410</span>		<span class="nx">MOVQ</span> <span class="mh">0x10</span><span class="p">(</span><span class="nx">SP</span><span class="p">),</span> <span class="nx">BP</span>                    <span class="c1">// mov 0x10(%rsp),%rbp</span>
  <span class="nx">main</span><span class="p">.</span><span class="nx">go</span><span class="o">:</span><span class="mi">9</span>		<span class="mh">0x48a</span>			<span class="mi">4883</span><span class="nx">c418</span>		<span class="nx">ADDQ</span> <span class="nx">$0x18</span><span class="p">,</span> <span class="nx">SP</span>                       <span class="c1">// add $0x18,%rsp</span>
  <span class="nx">main</span><span class="p">.</span><span class="nx">go</span><span class="o">:</span><span class="mi">9</span>		<span class="mh">0x48e</span>			<span class="nx">c3</span>			    <span class="nx">RET</span>                                  <span class="c1">// retq</span>
  <span class="nx">main</span><span class="p">.</span><span class="nx">go</span><span class="o">:</span><span class="mi">7</span>		<span class="mh">0x48f</span>			<span class="nx">e800000000</span>		<span class="nx">CALL</span> <span class="mh">0x494</span>                           <span class="c1">// callq 0x494		[1:5]R_CALL:runtime.morestack_noctxt</span>
  <span class="nx">main</span><span class="p">.</span><span class="nx">go</span><span class="o">:</span><span class="mi">7</span>		<span class="mh">0x494</span>			<span class="nx">eba5</span>			<span class="nx">JMP</span> <span class="o">%</span><span class="mi">22</span><span class="o">%</span><span class="mi">22</span><span class="p">.</span><span class="nx">main</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>                  <span class="c1">// jmp 0x43b</span>
</code></pre></div></div>

<p>对上面汇编的一点解释:</p>

<blockquote>
  <p>预备知识:</p>

  <ol>
    <li><a href="https://zhuanlan.zhihu.com/p/532514562">线程本地存储 TLS</a></li>
    <li><a href="https://zhuanlan.zhihu.com/p/426810334">GO 语言的运行时初始化过程解析</a></li>
  </ol>
</blockquote>

<ol>
  <li>0x43b ~ 0x448 是 Go 进入函数执行之前的初始化工作, 其实就是设置 TLS 以及运行时栈大小检查/分配</li>
  <li>0x44a ~ 0x453 是为 main 函数设置运行时栈, 栈空间大小设置为 <code class="language-plaintext highlighter-rouge">0x10</code>, 栈低指针被设置为 <code class="language-plaintext highlighter-rouge">0x10(%rsp)</code>, 也就是 <code class="language-plaintext highlighter-rouge">rsp</code> 再加上 10 的位置, 栈顶指针被设置为 <code class="language-plaintext highlighter-rouge">0x18(%rsp)</code> 位置.</li>
  <li>0x458 <code class="language-plaintext highlighter-rouge">nopl</code> 是一个无意义的指令, 纯粹是为了占位置. 如果函数有参数的话, 这里会是设置 <code class="language-plaintext highlighter-rouge">axx</code> 参数相关代码, <code class="language-plaintext highlighter-rouge">axx</code> 收到的参数实际上.</li>
  <li>0x45b 发起对函数 <code class="language-plaintext highlighter-rouge">axx</code> 的调用</li>
</ol>

<p>栈设置的具体解释(注意栈是往下生长的):</p>

<div class="language-as highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">;</span> <span class="err">开辟栈空间</span><span class="p">,</span> <span class="err">操作前的栈顶记为</span> <span class="nx">SP0</span><span class="p">,</span> <span class="err">栈顶指针现在是</span> <span class="nx">SP0</span> <span class="err">-</span> <span class="mh">0x18</span><span class="p">,</span> <span class="err">记为</span> <span class="nx">SP1</span>
<span class="o">;</span> <span class="err">此时</span> <span class="nx">SP0</span><span class="err">-</span><span class="nx">SP1</span> <span class="err">之间有</span> <span class="mh">0x18</span><span class="o">/</span><span class="mi">8</span> <span class="o">=</span> <span class="mi">3</span> <span class="err">个</span> <span class="mi">64</span> <span class="err">位存储单元</span><span class="o">:</span> <span class="p">(</span><span class="err">高地址</span><span class="p">,</span> <span class="nx">sp0</span><span class="p">)</span> <span class="p">[</span><span class="nx">X</span><span class="p">,</span> <span class="nx">X</span><span class="p">,</span> <span class="nx">X</span><span class="p">]</span> <span class="p">(</span><span class="err">低地址</span><span class="p">,</span> <span class="nx">sp1</span><span class="p">)</span>
<span class="nx">sub</span> <span class="nx">$0x18</span><span class="p">,</span><span class="o">%</span><span class="nx">rsp</span>

<span class="o">;</span> <span class="err">把原来的栈底记作</span> <span class="nx">BP0</span><span class="p">,</span> <span class="err">这一步将它保存在</span> <span class="err">`</span><span class="mh">0x10</span><span class="p">(</span><span class="o">%</span><span class="nx">rsp</span><span class="p">)</span><span class="err">`</span>
<span class="o">;</span> <span class="err">操作完了之后栈内容变为</span> <span class="p">(</span><span class="err">高地址</span><span class="p">,</span> <span class="nx">sp0</span><span class="p">)</span> <span class="p">[</span><span class="nx">BP0</span><span class="p">,</span> <span class="nx">X</span><span class="p">,</span> <span class="nx">X</span><span class="p">]</span> <span class="p">(</span><span class="err">低地址</span><span class="p">,</span> <span class="nx">sp1</span><span class="p">)</span>
<span class="nx">mov</span> <span class="o">%</span><span class="nx">rbp</span><span class="p">,</span><span class="mh">0x10</span><span class="p">(</span><span class="o">%</span><span class="nx">rsp</span><span class="p">)</span>

<span class="o">;</span> <span class="err">设置新的栈低</span><span class="p">,</span> <span class="err">操作完之后</span><span class="p">,</span> <span class="err">栈内容不变</span><span class="p">,</span> <span class="err">只是</span> <span class="nx">BP</span> <span class="err">寄存器发生了变化</span>
<span class="nx">lea</span> <span class="mh">0x10</span><span class="p">(</span><span class="o">%</span><span class="nx">rsp</span><span class="p">),</span><span class="o">%</span><span class="nx">rbp</span>

<span class="o">;</span> <span class="err">剩下的那两个栈存储区域</span><span class="p">,</span> <span class="err">在</span> <span class="nx">main</span> <span class="err">函数的其他地方用到了</span><span class="p">,</span> <span class="err">可以看上面完整的汇编</span>
</code></pre></div></div>]]></content><author><name>Zhigang Song</name></author><category term="golang" /><category term="assembly" /><category term="testing" /><category term="monkey-patching" /><summary type="html"><![CDATA[本文是 Monkey Patching in Go 的阅读理解. 原文 Monkey Patching in Go Many people think that monkey patching is something that is restricted to dynamic languages like Ruby and Python. That is not true however, as computers are just dumb machines and we can always make them do what we want! Let’s look at how Go functions work and how we can modify them at runtime. This article will use a lot of Intel assembly syntax, so I’m assuming you can read it already or are using a reference while reading.]]></summary></entry><entry><title type="html">python 的 metaclass 到底是什么</title><link href="http://sidgwick.github.io/2023/04/14/metaclass.html" rel="alternate" type="text/html" title="python 的 metaclass 到底是什么" /><published>2023-04-14T10:28:04+08:00</published><updated>2023-04-14T10:28:04+08:00</updated><id>http://sidgwick.github.io/2023/04/14/metaclass</id><content type="html" xml:base="http://sidgwick.github.io/2023/04/14/metaclass.html"><![CDATA[<blockquote>
  <p>文章地址: <a href="https://stackoverflow.com/questions/100003/what-are-metaclasses-in-python?answertab=votes#tab-top">https://stackoverflow.com/questions/100003/what-are-metaclasses-in-python?answertab=votes#tab-top</a></p>
</blockquote>

<h1 id="classes-as-objects">Classes as objects</h1>

<p>Before understanding metaclasses, it helps to understand Python classes more deeply. Python has a very peculiar idea of what classes are, which it borrows from the Smalltalk language.</p>

<p>In most languages, classes are just pieces of code that describe how to produce an object. That is somewhat true in Python too:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="k">class</span> <span class="nc">ObjectCreator</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="p">...</span>       <span class="k">pass</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">my_object</span> <span class="o">=</span> <span class="nc">ObjectCreator</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nf">print</span><span class="p">(</span><span class="n">my_object</span><span class="p">)</span>
<span class="o">&lt;</span><span class="n">__main__</span><span class="p">.</span><span class="n">ObjectCreator</span> <span class="nb">object</span> <span class="n">at</span> <span class="mh">0x8974f2c</span><span class="o">&gt;</span>
</code></pre></div></div>

<!--more-->

<p>But classes are more than that in Python. Classes are objects too.</p>

<p>Yes, objects.</p>

<p>When a Python script runs, every line of code is executed from top to bottom. When the Python interpreter encounters the class keyword, Python creates an object out of the “description” of the class that follows. Thus, the following instruction</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="k">class</span> <span class="nc">ObjectCreator</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="p">...</span>       <span class="k">pass</span>
</code></pre></div></div>

<p>…creates an object with the name ObjectCreator!</p>

<p>This object (the class) is itself capable of creating objects (called instances).</p>

<p>But still, it’s an object. Therefore, like all objects:</p>

<p>you can assign it to a variable<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">JustAnotherVariable</span> <span class="o">=</span> <span class="n">ObjectCreator</span>
</code></pre></div></div>

<p>you can attach attributes to it</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ObjectCreator</span><span class="p">.</span><span class="n">class_attribute</span> <span class="o">=</span> <span class="sh">'</span><span class="s">foo</span><span class="sh">'</span>
</code></pre></div></div>

<p>you can pass it as a function parameter</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">print</span><span class="p">(</span><span class="n">ObjectCreator</span><span class="p">)</span>
</code></pre></div></div>

<p>Note that merely assigning it to another variable doesn’t change the class’s <strong>name</strong>, i.e.,</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="nf">print</span><span class="p">(</span><span class="n">JustAnotherVariable</span><span class="p">)</span>
<span class="o">&lt;</span><span class="k">class</span> <span class="err">'</span><span class="nc">__main__</span><span class="p">.</span><span class="n">ObjectCreator</span><span class="sh">'</span><span class="s">&gt;
</span><span class="gp">
&gt;&gt;&gt;</span> <span class="nf">print</span><span class="p">(</span><span class="nc">JustAnotherVariable</span><span class="p">())</span>
<span class="o">&lt;</span><span class="n">__main__</span><span class="p">.</span><span class="n">ObjectCreator</span> <span class="nb">object</span> <span class="n">at</span> <span class="mh">0x8997b4c</span><span class="o">&gt;</span>
</code></pre></div></div>

<h1 id="creating-classes-dynamically">Creating classes dynamically</h1>

<p>Since classes are objects, you can create them on the fly, like any object.</p>

<p>First, you can create a class in a function using class:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">choose_class</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
<span class="p">...</span>     <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="sh">'</span><span class="s">foo</span><span class="sh">'</span><span class="p">:</span>
<span class="p">...</span>         <span class="k">class</span> <span class="nc">Foo</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="p">...</span>             <span class="k">pass</span>
<span class="p">...</span>         <span class="k">return</span> <span class="n">Foo</span> <span class="c1"># return the class, not an instance
</span><span class="p">...</span>     <span class="k">else</span><span class="p">:</span>
<span class="p">...</span>         <span class="k">class</span> <span class="nc">Bar</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="p">...</span>             <span class="k">pass</span>
<span class="p">...</span>         <span class="k">return</span> <span class="n">Bar</span>
<span class="bp">...</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">MyClass</span> <span class="o">=</span> <span class="nf">choose_class</span><span class="p">(</span><span class="sh">'</span><span class="s">foo</span><span class="sh">'</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nf">print</span><span class="p">(</span><span class="n">MyClass</span><span class="p">)</span> <span class="c1"># the function returns a class, not an instance
</span><span class="o">&lt;</span><span class="k">class</span> <span class="err">'</span><span class="nc">__main__</span><span class="p">.</span><span class="n">Foo</span><span class="sh">'</span><span class="s">&gt;
</span><span class="gp">&gt;&gt;&gt;</span> <span class="nf">print</span><span class="p">(</span><span class="nc">MyClass</span><span class="p">())</span> <span class="c1"># you can create an object from this class
</span><span class="o">&lt;</span><span class="n">__main__</span><span class="p">.</span><span class="n">Foo</span> <span class="nb">object</span> <span class="n">at</span> <span class="mh">0x89c6d4c</span><span class="o">&gt;</span>
</code></pre></div></div>

<p>But it’s not so dynamic, since you still have to write the whole class yourself.</p>

<p>Since classes are objects, they must be generated by something.</p>

<p>When you use the class keyword, Python creates this object automatically. But as with most things in Python, it gives you a way to do it manually.</p>

<p>Remember the function type? The good old function that lets you know what type an object is:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="nf">print</span><span class="p">(</span><span class="nf">type</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="o">&lt;</span><span class="nb">type</span> <span class="sh">'</span><span class="s">int</span><span class="sh">'</span><span class="o">&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nf">print</span><span class="p">(</span><span class="nf">type</span><span class="p">(</span><span class="sh">"</span><span class="s">1</span><span class="sh">"</span><span class="p">))</span>
<span class="o">&lt;</span><span class="nb">type</span> <span class="sh">'</span><span class="s">str</span><span class="sh">'</span><span class="o">&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nf">print</span><span class="p">(</span><span class="nf">type</span><span class="p">(</span><span class="n">ObjectCreator</span><span class="p">))</span>
<span class="o">&lt;</span><span class="nb">type</span> <span class="sh">'</span><span class="s">type</span><span class="sh">'</span><span class="o">&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nf">print</span><span class="p">(</span><span class="nf">type</span><span class="p">(</span><span class="nc">ObjectCreator</span><span class="p">()))</span>
<span class="o">&lt;</span><span class="k">class</span> <span class="err">'</span><span class="nc">__main__</span><span class="p">.</span><span class="n">ObjectCreator</span><span class="sh">'</span><span class="s">&gt;
</span></code></pre></div></div>

<p>Well, type has also a completely different ability: it can create classes on the fly. type can take the description of a class as parameters, and return a class.</p>

<p>(I know, it’s silly that the same function can have two completely different uses according to the parameters you pass to it. It’s an issue due to backward compatibility in Python)</p>

<p>type works this way:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">type</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span>
</code></pre></div></div>

<p>Where:</p>

<ul>
  <li>name: name of the class</li>
  <li>bases: tuple of the parent class (for inheritance, can be empty)</li>
  <li>attrs: dictionary containing attributes names and values</li>
</ul>

<p>e.g.:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="k">class</span> <span class="nc">MyShinyClass</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="p">...</span>       <span class="k">pass</span>
</code></pre></div></div>

<p>can be created manually this way:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">MyShinyClass</span> <span class="o">=</span> <span class="nf">type</span><span class="p">(</span><span class="sh">'</span><span class="s">MyShinyClass</span><span class="sh">'</span><span class="p">,</span> <span class="p">(),</span> <span class="p">{})</span> <span class="c1"># returns a class object
</span><span class="o">&gt;&gt;&gt;</span> <span class="nf">print</span><span class="p">(</span><span class="n">MyShinyClass</span><span class="p">)</span>
<span class="o">&lt;</span><span class="k">class</span> <span class="err">'</span><span class="nc">__main__</span><span class="p">.</span><span class="n">MyShinyClass</span><span class="sh">'</span><span class="s">&gt;
</span><span class="gp">&gt;&gt;&gt;</span> <span class="nf">print</span><span class="p">(</span><span class="nc">MyShinyClass</span><span class="p">())</span> <span class="c1"># create an instance with the class
</span><span class="o">&lt;</span><span class="n">__main__</span><span class="p">.</span><span class="n">MyShinyClass</span> <span class="nb">object</span> <span class="n">at</span> <span class="mh">0x8997cec</span><span class="o">&gt;</span>
</code></pre></div></div>

<p>You’ll notice that we use MyShinyClass as the name of the class and as the variable to hold the class reference. They can be different, but there is no reason to complicate things.</p>

<p>type accepts a dictionary to define the attributes of the class. So:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="k">class</span> <span class="nc">Foo</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="p">...</span>       <span class="n">bar</span> <span class="o">=</span> <span class="bp">True</span>
</code></pre></div></div>

<p>Can be translated to:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">Foo</span> <span class="o">=</span> <span class="nf">type</span><span class="p">(</span><span class="sh">'</span><span class="s">Foo</span><span class="sh">'</span><span class="p">,</span> <span class="p">(),</span> <span class="p">{</span><span class="sh">'</span><span class="s">bar</span><span class="sh">'</span><span class="p">:</span><span class="bp">True</span><span class="p">})</span>
</code></pre></div></div>

<p>And used as a normal class:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="nf">print</span><span class="p">(</span><span class="n">Foo</span><span class="p">)</span>
<span class="o">&lt;</span><span class="k">class</span> <span class="err">'</span><span class="nc">__main__</span><span class="p">.</span><span class="n">Foo</span><span class="sh">'</span><span class="s">&gt;
</span><span class="gp">&gt;&gt;&gt;</span> <span class="nf">print</span><span class="p">(</span><span class="n">Foo</span><span class="p">.</span><span class="n">bar</span><span class="p">)</span>
<span class="bp">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">f</span> <span class="o">=</span> <span class="nc">Foo</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nf">print</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="o">&lt;</span><span class="n">__main__</span><span class="p">.</span><span class="n">Foo</span> <span class="nb">object</span> <span class="n">at</span> <span class="mh">0x8a9b84c</span><span class="o">&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nf">print</span><span class="p">(</span><span class="n">f</span><span class="p">.</span><span class="n">bar</span><span class="p">)</span>
<span class="bp">True</span>
</code></pre></div></div>

<p>And of course, you can inherit from it, so:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span>   <span class="k">class</span> <span class="nc">FooChild</span><span class="p">(</span><span class="n">Foo</span><span class="p">):</span>
<span class="p">...</span>         <span class="k">pass</span>
</code></pre></div></div>

<p>would be:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">FooChild</span> <span class="o">=</span> <span class="nf">type</span><span class="p">(</span><span class="sh">'</span><span class="s">FooChild</span><span class="sh">'</span><span class="p">,</span> <span class="p">(</span><span class="n">Foo</span><span class="p">,),</span> <span class="p">{})</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nf">print</span><span class="p">(</span><span class="n">FooChild</span><span class="p">)</span>
<span class="o">&lt;</span><span class="k">class</span> <span class="err">'</span><span class="nc">__main__</span><span class="p">.</span><span class="n">FooChild</span><span class="sh">'</span><span class="s">&gt;
</span><span class="gp">&gt;&gt;&gt;</span> <span class="nf">print</span><span class="p">(</span><span class="n">FooChild</span><span class="p">.</span><span class="n">bar</span><span class="p">)</span> <span class="c1"># bar is inherited from Foo
</span><span class="bp">True</span>
</code></pre></div></div>

<p>Eventually, you’ll want to add methods to your class. Just define a function with the proper signature and assign it as an attribute.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">echo_bar</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
<span class="p">...</span>       <span class="nf">print</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">bar</span><span class="p">)</span>
<span class="bp">...</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">FooChild</span> <span class="o">=</span> <span class="nf">type</span><span class="p">(</span><span class="sh">'</span><span class="s">FooChild</span><span class="sh">'</span><span class="p">,</span> <span class="p">(</span><span class="n">Foo</span><span class="p">,),</span> <span class="p">{</span><span class="sh">'</span><span class="s">echo_bar</span><span class="sh">'</span><span class="p">:</span> <span class="n">echo_bar</span><span class="p">})</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nf">hasattr</span><span class="p">(</span><span class="n">Foo</span><span class="p">,</span> <span class="sh">'</span><span class="s">echo_bar</span><span class="sh">'</span><span class="p">)</span>
<span class="bp">False</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nf">hasattr</span><span class="p">(</span><span class="n">FooChild</span><span class="p">,</span> <span class="sh">'</span><span class="s">echo_bar</span><span class="sh">'</span><span class="p">)</span>
<span class="bp">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">my_foo</span> <span class="o">=</span> <span class="nc">FooChild</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">my_foo</span><span class="p">.</span><span class="nf">echo_bar</span><span class="p">()</span>
<span class="bp">True</span>
</code></pre></div></div>

<p>And you can add even more methods after you dynamically create the class, just like adding methods to a normally created class object.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">echo_bar_more</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
<span class="p">...</span>       <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">yet another method</span><span class="sh">'</span><span class="p">)</span>
<span class="bp">...</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">FooChild</span><span class="p">.</span><span class="n">echo_bar_more</span> <span class="o">=</span> <span class="n">echo_bar_more</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nf">hasattr</span><span class="p">(</span><span class="n">FooChild</span><span class="p">,</span> <span class="sh">'</span><span class="s">echo_bar_more</span><span class="sh">'</span><span class="p">)</span>
<span class="bp">True</span>
</code></pre></div></div>

<p>You see where we are going: in Python, classes are objects, and you can create a class on the fly, dynamically.</p>

<p>This is what Python does when you use the keyword class, and it does so by using a metaclass.</p>

<h1 id="what-are-metaclasses-finally">What are metaclasses (finally)</h1>

<p>Metaclasses are the ‘stuff’ that creates classes.</p>

<p>You define classes in order to create objects, right?</p>

<p>But we learned that Python classes are objects.</p>

<p>Well, metaclasses are what create these objects. They are the classes’ classes, you can picture them this way:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">MyClass</span> <span class="o">=</span> <span class="nc">MetaClass</span><span class="p">()</span>
<span class="n">my_object</span> <span class="o">=</span> <span class="nc">MyClass</span><span class="p">()</span>
</code></pre></div></div>

<p>You’ve seen that type lets you do something like this:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">MyClass</span> <span class="o">=</span> <span class="nf">type</span><span class="p">(</span><span class="sh">'</span><span class="s">MyClass</span><span class="sh">'</span><span class="p">,</span> <span class="p">(),</span> <span class="p">{})</span>
</code></pre></div></div>

<p>It’s because the function <code class="language-plaintext highlighter-rouge">type</code> is in fact a metaclass. type is the metaclass Python uses to create all classes behind the scenes.</p>

<p>Now you wonder “why the heck is it written in lowercase, and not <code class="language-plaintext highlighter-rouge">Type</code>?”</p>

<p>Well, I guess it’s a matter of consistency with <code class="language-plaintext highlighter-rouge">str</code>, the class that creates strings objects, and <code class="language-plaintext highlighter-rouge">int</code> the class that creates integer objects. <code class="language-plaintext highlighter-rouge">type</code> is just the class that creates class objects.</p>

<p>You see that by checking the <code class="language-plaintext highlighter-rouge">__class__</code> attribute.</p>

<p>Everything, and I mean everything, is an object in Python. That includes integers, strings, functions and classes. All of them are objects. And all of them have been created from a class:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">age</span> <span class="o">=</span> <span class="mi">35</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">age</span><span class="p">.</span><span class="n">__class__</span>
<span class="o">&lt;</span><span class="nb">type</span> <span class="sh">'</span><span class="s">int</span><span class="sh">'</span><span class="o">&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">name</span> <span class="o">=</span> <span class="sh">'</span><span class="s">bob</span><span class="sh">'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">name</span><span class="p">.</span><span class="n">__class__</span>
<span class="o">&lt;</span><span class="nb">type</span> <span class="sh">'</span><span class="s">str</span><span class="sh">'</span><span class="o">&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">foo</span><span class="p">():</span> <span class="k">pass</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">foo</span><span class="p">.</span><span class="n">__class__</span>
<span class="o">&lt;</span><span class="nb">type</span> <span class="sh">'</span><span class="s">function</span><span class="sh">'</span><span class="o">&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">class</span> <span class="nc">Bar</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span> <span class="k">pass</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="nc">Bar</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span><span class="p">.</span><span class="n">__class__</span>
<span class="o">&lt;</span><span class="k">class</span> <span class="err">'</span><span class="nc">__main__</span><span class="p">.</span><span class="n">Bar</span><span class="sh">'</span><span class="s">&gt;
</span></code></pre></div></div>

<p>Now, what is the <code class="language-plaintext highlighter-rouge">__class__</code> of any <code class="language-plaintext highlighter-rouge">__class__</code> ?</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">age</span><span class="p">.</span><span class="n">__class__</span><span class="p">.</span><span class="n">__class__</span>
<span class="o">&lt;</span><span class="nb">type</span> <span class="sh">'</span><span class="s">type</span><span class="sh">'</span><span class="o">&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">name</span><span class="p">.</span><span class="n">__class__</span><span class="p">.</span><span class="n">__class__</span>
<span class="o">&lt;</span><span class="nb">type</span> <span class="sh">'</span><span class="s">type</span><span class="sh">'</span><span class="o">&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">foo</span><span class="p">.</span><span class="n">__class__</span><span class="p">.</span><span class="n">__class__</span>
<span class="o">&lt;</span><span class="nb">type</span> <span class="sh">'</span><span class="s">type</span><span class="sh">'</span><span class="o">&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span><span class="p">.</span><span class="n">__class__</span><span class="p">.</span><span class="n">__class__</span>
<span class="o">&lt;</span><span class="nb">type</span> <span class="sh">'</span><span class="s">type</span><span class="sh">'</span><span class="o">&gt;</span>
</code></pre></div></div>

<p>So, a metaclass is just the stuff that creates class objects.</p>

<p>You can call it a ‘class factory’ if you wish.</p>

<p>type is the built-in metaclass Python uses, but of course, you can create your own metaclass.</p>

<h2 id="the-__metaclass__-attribute">The <code class="language-plaintext highlighter-rouge">__metaclass__</code> attribute</h2>

<p>In Python 2, you can add a <code class="language-plaintext highlighter-rouge">__metaclass__</code> attribute when you write a class (see next section for the Python 3 syntax):</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Foo</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">__metaclass__</span> <span class="o">=</span> <span class="n">something</span><span class="bp">...</span>
    <span class="p">[...]</span>
</code></pre></div></div>

<p>If you do so, Python will use the metaclass to create the class <code class="language-plaintext highlighter-rouge">Foo</code>.</p>

<p>Careful, it’s tricky.</p>

<p>You write <code class="language-plaintext highlighter-rouge">class Foo(object)</code> first, but the class object <code class="language-plaintext highlighter-rouge">Foo</code> is not created in memory yet.</p>

<p>Python will look for <code class="language-plaintext highlighter-rouge">__metaclass__</code> in the class definition. If it finds it, it will use it to create the object class <code class="language-plaintext highlighter-rouge">Foo</code>. If it doesn’t, it will use type to create the class.</p>

<p>Read that several times.</p>

<p>When you do:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Foo</span><span class="p">(</span><span class="n">Bar</span><span class="p">):</span>
    <span class="k">pass</span>
</code></pre></div></div>

<p>Python does the following:</p>

<p>Is there a <code class="language-plaintext highlighter-rouge">__metaclass__</code> attribute in <code class="language-plaintext highlighter-rouge">Foo</code>?</p>

<p>If yes, create in-memory a class object (I said a <em>class object</em>, stay with me here), with the name <code class="language-plaintext highlighter-rouge">Foo</code> by using what is in <code class="language-plaintext highlighter-rouge">__metaclass__</code>.</p>

<p>If Python can’t find <code class="language-plaintext highlighter-rouge">__metaclass__</code>, it will look for a <code class="language-plaintext highlighter-rouge">__metaclass__</code> at the MODULE level, and try to do the same (but only for classes that don’t inherit anything, basically old-style classes).</p>

<p>Then if it can’t find any <code class="language-plaintext highlighter-rouge">__metaclass__</code> at all, it will use the <code class="language-plaintext highlighter-rouge">Bar</code>’s (the first parent) own metaclass (which might be the default type) to create the class object.</p>

<blockquote>
  <p>TODO: 下面这段什么意思?
Be careful here that the <code class="language-plaintext highlighter-rouge">__metaclass__</code> attribute will not be inherited, the metaclass of the parent (<code class="language-plaintext highlighter-rouge">Bar.__class__</code>) will be. If <code class="language-plaintext highlighter-rouge">Bar</code> used a <code class="language-plaintext highlighter-rouge">__metaclass__</code> attribute that created <code class="language-plaintext highlighter-rouge">Bar</code> with <code class="language-plaintext highlighter-rouge">type()</code> (and <em>not</em> <code class="language-plaintext highlighter-rouge">type.__new__()</code>), the subclasses will not inherit that behavior.</p>
</blockquote>

<p>Now the big question is, what can you put in <code class="language-plaintext highlighter-rouge">__metaclass__</code>?</p>

<p>The answer is something that can create a class.</p>

<p>And what can create a class? type, or anything that subclasses or uses it.</p>

<h1 id="metaclasses-in-python-3">Metaclasses in Python 3</h1>

<p>The syntax to set the metaclass has been changed in Python 3:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Foo</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">something</span><span class="p">):</span>
    <span class="bp">...</span>
</code></pre></div></div>

<p>i.e. the <code class="language-plaintext highlighter-rouge">__metaclass__</code> attribute is no longer used, in favor of a keyword argument in the list of base classes.</p>

<p>The behavior of metaclasses however stays largely the same.</p>

<p>One thing added to metaclasses in Python 3 is that you can also pass attributes as keyword-arguments into a metaclass, like so:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Foo</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">something</span><span class="p">,</span> <span class="n">kwarg1</span><span class="o">=</span><span class="n">value1</span><span class="p">,</span> <span class="n">kwarg2</span><span class="o">=</span><span class="n">value2</span><span class="p">):</span>
    <span class="bp">...</span>
</code></pre></div></div>

<p>Read the section below for how Python handles this.</p>

<h2 id="custom-metaclasses">Custom metaclasses</h2>

<p>The main purpose of a metaclass is to change the class automatically, when it’s created.</p>

<p>You usually do this for APIs, where you want to create classes matching the current context.</p>

<p>Imagine a stupid example, where you decide that all classes in your module should have their attributes written in uppercase. There are several ways to do this, but one way is to set <code class="language-plaintext highlighter-rouge">__metaclass__</code> at the module level.</p>

<p>This way, all classes of this module will be created using this metaclass, and we just have to tell the metaclass to turn all attributes to uppercase.</p>

<p>Luckily, <code class="language-plaintext highlighter-rouge">__metaclass__</code> can actually be any callable, it doesn’t need to be a formal class (I know, something with ‘class’ in its name doesn’t need to be a class, go figure… but it’s helpful).</p>

<p>So we will start with a simple example, by using a function.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># the metaclass will automatically get passed the same argument
# that you usually pass to `type`
</span><span class="k">def</span> <span class="nf">upper_attr</span><span class="p">(</span><span class="n">future_class_name</span><span class="p">,</span> <span class="n">future_class_parents</span><span class="p">,</span> <span class="n">future_class_attrs</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">
      Return a class object, with the list of its attribute turned
      into uppercase.
    </span><span class="sh">"""</span>
    <span class="c1"># pick up any attribute that doesn't start with '__' and uppercase it
</span>    <span class="n">uppercase_attrs</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">attr</span> <span class="k">if</span> <span class="n">attr</span><span class="p">.</span><span class="nf">startswith</span><span class="p">(</span><span class="sh">"</span><span class="s">__</span><span class="sh">"</span><span class="p">)</span> <span class="k">else</span> <span class="n">attr</span><span class="p">.</span><span class="nf">upper</span><span class="p">():</span> <span class="n">v</span>
        <span class="k">for</span> <span class="n">attr</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">future_class_attrs</span><span class="p">.</span><span class="nf">items</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="c1"># let `type` do the class creation
</span>    <span class="k">return</span> <span class="nf">type</span><span class="p">(</span><span class="n">future_class_name</span><span class="p">,</span> <span class="n">future_class_parents</span><span class="p">,</span> <span class="n">uppercase_attrs</span><span class="p">)</span>

<span class="n">__metaclass__</span> <span class="o">=</span> <span class="n">upper_attr</span> <span class="c1"># this will affect all classes in the module
</span>
<span class="k">class</span> <span class="nc">Foo</span><span class="p">():</span> <span class="c1"># global __metaclass__ won't work with "object" though
</span>    <span class="c1"># but we can define __metaclass__ here instead to affect only this class
</span>    <span class="c1"># and this will work with "object" children
</span>    <span class="n">bar</span> <span class="o">=</span> <span class="sh">'</span><span class="s">bip</span><span class="sh">'</span>
</code></pre></div></div>

<p>Let’s check:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="nf">hasattr</span><span class="p">(</span><span class="n">Foo</span><span class="p">,</span> <span class="sh">'</span><span class="s">bar</span><span class="sh">'</span><span class="p">)</span>
<span class="bp">False</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nf">hasattr</span><span class="p">(</span><span class="n">Foo</span><span class="p">,</span> <span class="sh">'</span><span class="s">BAR</span><span class="sh">'</span><span class="p">)</span>
<span class="bp">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Foo</span><span class="p">.</span><span class="n">BAR</span>
<span class="sh">'</span><span class="s">bip</span><span class="sh">'</span>
</code></pre></div></div>

<p>Now, let’s do exactly the same, but using a real class for a metaclass:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># remember that `type` is actually a class like `str` and `int`
# so you can inherit from it
</span><span class="k">class</span> <span class="nc">UpperAttrMetaclass</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="c1"># __new__ is the method called before __init__
</span>    <span class="c1"># it's the method that creates the object and returns it
</span>    <span class="c1"># while __init__ just initializes the object passed as parameter
</span>    <span class="c1"># you rarely use __new__, except when you want to control how the object
</span>    <span class="c1"># is created.
</span>    <span class="c1"># here the created object is the class, and we want to customize it
</span>    <span class="c1"># so we override __new__
</span>    <span class="c1"># you can do some stuff in __init__ too if you wish
</span>    <span class="c1"># some advanced use involves overriding __call__ as well, but we won't
</span>    <span class="c1"># see this
</span>    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">upperattr_metaclass</span><span class="p">,</span> <span class="n">future_class_name</span><span class="p">,</span>
                <span class="n">future_class_parents</span><span class="p">,</span> <span class="n">future_class_attrs</span><span class="p">):</span>
        <span class="n">uppercase_attrs</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">attr</span> <span class="k">if</span> <span class="n">attr</span><span class="p">.</span><span class="nf">startswith</span><span class="p">(</span><span class="sh">"</span><span class="s">__</span><span class="sh">"</span><span class="p">)</span> <span class="k">else</span> <span class="n">attr</span><span class="p">.</span><span class="nf">upper</span><span class="p">():</span> <span class="n">v</span>
            <span class="k">for</span> <span class="n">attr</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">future_class_attrs</span><span class="p">.</span><span class="nf">items</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nf">type</span><span class="p">(</span><span class="n">future_class_name</span><span class="p">,</span> <span class="n">future_class_parents</span><span class="p">,</span> <span class="n">uppercase_attrs</span><span class="p">)</span>
</code></pre></div></div>

<p>Let’s rewrite the above, but with shorter and more realistic variable names now that we know what they mean:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">UpperAttrMetaclass</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">clsname</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">):</span>
        <span class="n">uppercase_attrs</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">attr</span> <span class="k">if</span> <span class="n">attr</span><span class="p">.</span><span class="nf">startswith</span><span class="p">(</span><span class="sh">"</span><span class="s">__</span><span class="sh">"</span><span class="p">)</span> <span class="k">else</span> <span class="n">attr</span><span class="p">.</span><span class="nf">upper</span><span class="p">():</span> <span class="n">v</span>
            <span class="k">for</span> <span class="n">attr</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">attrs</span><span class="p">.</span><span class="nf">items</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nf">type</span><span class="p">(</span><span class="n">clsname</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">uppercase_attrs</span><span class="p">)</span>
</code></pre></div></div>

<p>You may have noticed the extra argument cls. There is nothing special about it: <code class="language-plaintext highlighter-rouge">__new__</code> always receives the class it’s defined in, as the first parameter. Just like you have self for ordinary methods which receive the instance as the first parameter, or the defining class for class methods.</p>

<p>But this is not proper OOP. We are calling type directly and we aren’t overriding or calling the parent’s <code class="language-plaintext highlighter-rouge">__new__</code>. Let’s do that instead:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">UpperAttrMetaclass</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">clsname</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">):</span>
        <span class="n">uppercase_attrs</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">attr</span> <span class="k">if</span> <span class="n">attr</span><span class="p">.</span><span class="nf">startswith</span><span class="p">(</span><span class="sh">"</span><span class="s">__</span><span class="sh">"</span><span class="p">)</span> <span class="k">else</span> <span class="n">attr</span><span class="p">.</span><span class="nf">upper</span><span class="p">():</span> <span class="n">v</span>
            <span class="k">for</span> <span class="n">attr</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">attrs</span><span class="p">.</span><span class="nf">items</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">.</span><span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">clsname</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">uppercase_attrs</span><span class="p">)</span>
</code></pre></div></div>

<p>We can make it even cleaner by using super, which will ease inheritance (because yes, you can have metaclasses, inheriting from metaclasses, inheriting from type):</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">UpperAttrMetaclass</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">clsname</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">):</span>
        <span class="n">uppercase_attrs</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">attr</span> <span class="k">if</span> <span class="n">attr</span><span class="p">.</span><span class="nf">startswith</span><span class="p">(</span><span class="sh">"</span><span class="s">__</span><span class="sh">"</span><span class="p">)</span> <span class="k">else</span> <span class="n">attr</span><span class="p">.</span><span class="nf">upper</span><span class="p">():</span> <span class="n">v</span>
            <span class="k">for</span> <span class="n">attr</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">attrs</span><span class="p">.</span><span class="nf">items</span><span class="p">()</span>
        <span class="p">}</span>

        <span class="c1"># Python 2 requires passing arguments to super:
</span>        <span class="k">return</span> <span class="nf">super</span><span class="p">(</span><span class="n">UpperAttrMetaclass</span><span class="p">,</span> <span class="n">cls</span><span class="p">).</span><span class="nf">__new__</span><span class="p">(</span>
            <span class="n">cls</span><span class="p">,</span> <span class="n">clsname</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">uppercase_attrs</span><span class="p">)</span>

        <span class="c1"># Python 3 can use no-arg super() which infers them:
</span>        <span class="k">return</span> <span class="nf">super</span><span class="p">().</span><span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">clsname</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">uppercase_attrs</span><span class="p">)</span>
</code></pre></div></div>

<p>Oh, and in Python 3 if you do this call with keyword arguments, like this:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Foo</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">MyMetaclass</span><span class="p">,</span> <span class="n">kwarg1</span><span class="o">=</span><span class="n">value1</span><span class="p">):</span>
    <span class="bp">...</span>
</code></pre></div></div>

<p>It translates to this in the metaclass to use it:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MyMetaclass</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">clsname</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">dct</span><span class="p">,</span> <span class="n">kwargs1</span><span class="o">=</span><span class="n">default</span><span class="p">):</span>
        <span class="bp">...</span>
</code></pre></div></div>

<p>That’s it. There is really nothing more about metaclasses.</p>

<p>The reason behind the complexity of the code using metaclasses is not because of metaclasses, it’s because you usually use metaclasses to do twisted stuff relying on introspection, manipulating inheritance, vars such as <code class="language-plaintext highlighter-rouge">__dict__</code>, etc.</p>

<p>Indeed, metaclasses are especially useful to do black magic, and therefore complicated stuff. But by themselves, they are simple:</p>

<ul>
  <li>intercept a class creation</li>
  <li>modify the class</li>
  <li>return the modified class</li>
</ul>

<h2 id="why-would-you-use-metaclasses-classes-instead-of-functions">Why would you use metaclasses classes instead of functions?</h2>

<p>Since <code class="language-plaintext highlighter-rouge">__metaclass__</code> can accept any callable, why would you use a class since it’s obviously more complicated?</p>

<p>There are several reasons to do so:</p>

<ul>
  <li>The intention is clear. When you read <code class="language-plaintext highlighter-rouge">UpperAttrMetaclass(type)</code>, you know what’s going to follow</li>
  <li>You can use OOP. Metaclass can inherit from metaclass, override parent methods. Metaclasses can even use metaclasses.</li>
  <li>Subclasses of a class will be instances of its metaclass if you specified a metaclass-class, but not with a metaclass-function.</li>
  <li>You can structure your code better. You never use metaclasses for something as trivial as the above example. It’s usually for something complicated. Having the ability to make several methods and group them in one class is very useful to make the code easier to read.</li>
  <li>You can hook on <code class="language-plaintext highlighter-rouge">__new__</code>, <code class="language-plaintext highlighter-rouge">__init__</code> and <code class="language-plaintext highlighter-rouge">__call__</code>. Which will allow you to do different stuff, Even if usually you can do it all in <code class="language-plaintext highlighter-rouge">__new__</code>, some people are just more comfortable using <code class="language-plaintext highlighter-rouge">__init__</code>.</li>
  <li>These are called metaclasses, damn it! It must mean something!</li>
</ul>

<h2 id="why-would-you-use-metaclasses">Why would you use metaclasses?</h2>

<p>Now the big question. Why would you use some obscure error-prone feature?</p>

<p>Well, usually you don’t:</p>

<blockquote>
  <p>Metaclasses are deeper magic that 99% of users should never worry about it. If you wonder whether you need them, you don’t (the people who actually need them know with certainty that they need them, and don’t need an explanation about why).</p>

  <p>Python Guru Tim Peters</p>
</blockquote>

<p>The main use case for a metaclass is creating an API. A typical example of this is the Django ORM. It allows you to define something like this:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Person</span><span class="p">(</span><span class="n">models</span><span class="p">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">models</span><span class="p">.</span><span class="nc">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
    <span class="n">age</span> <span class="o">=</span> <span class="n">models</span><span class="p">.</span><span class="nc">IntegerField</span><span class="p">()</span>
</code></pre></div></div>

<p>But if you do this:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">person</span> <span class="o">=</span> <span class="nc">Person</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="sh">'</span><span class="s">bob</span><span class="sh">'</span><span class="p">,</span> <span class="n">age</span><span class="o">=</span><span class="sh">'</span><span class="s">35</span><span class="sh">'</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">person</span><span class="p">.</span><span class="n">age</span><span class="p">)</span>
</code></pre></div></div>

<p>It won’t return an <code class="language-plaintext highlighter-rouge">IntegerField</code> object. It will return an <code class="language-plaintext highlighter-rouge">int</code>, and can even take it directly from the database.</p>

<p>This is possible because <code class="language-plaintext highlighter-rouge">models.Model</code> defines <code class="language-plaintext highlighter-rouge">__metaclass__</code> and it uses some magic that will turn the <code class="language-plaintext highlighter-rouge">Person</code> you just defined with simple statements into a complex hook to a database field.</p>

<p>Django makes something complex look simple by exposing a simple API and using metaclasses, recreating code from this API to do the real job behind the scenes.</p>

<h1 id="the-last-word">The last word</h1>

<p>First, you know that classes are objects that can create instances.</p>

<p>Well, in fact, classes are themselves instances. Of metaclasses.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="k">class</span> <span class="nc">Foo</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span> <span class="k">pass</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nf">id</span><span class="p">(</span><span class="n">Foo</span><span class="p">)</span>
<span class="mi">142630324</span>
</code></pre></div></div>

<p>Everything is an object in Python, and they are all either instance of classes or instances of metaclasses.</p>

<p>Except for <code class="language-plaintext highlighter-rouge">type</code>.</p>

<p><code class="language-plaintext highlighter-rouge">type</code> is actually its own metaclass. This is not something you could reproduce in pure Python, and is done by cheating a little bit at the implementation level.</p>

<p>Secondly, metaclasses are complicated. You may not want to use them for very simple class alterations. You can change classes by using two different techniques:</p>

<ul>
  <li><a href="https://en.wikipedia.org/wiki/Monkey_patch">monkey patching</a></li>
  <li>class decorators</li>
</ul>

<p>99% of the time you need class alteration, you are better off using these.</p>

<p>But 98% of the time, you don’t need class alteration at all.</p>
<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">

      <p><a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name>Zhigang Song</name></author><category term="python" /><category term="oop" /><category term="metaclass" /><summary type="html"><![CDATA[文章地址: https://stackoverflow.com/questions/100003/what-are-metaclasses-in-python?answertab=votes#tab-top Classes as objects Before understanding metaclasses, it helps to understand Python classes more deeply. Python has a very peculiar idea of what classes are, which it borrows from the Smalltalk language. In most languages, classes are just pieces of code that describe how to produce an object. That is somewhat true in Python too: &gt;&gt;&gt; class ObjectCreator(object): ... pass &gt;&gt;&gt; my_object = ObjectCreator() &gt;&gt;&gt; print(my_object) &lt;__main__.ObjectCreator object at 0x8974f2c&gt;]]></summary></entry><entry><title type="html">python 元编程</title><link href="http://sidgwick.github.io/2023/04/14/meta-programming.html" rel="alternate" type="text/html" title="python 元编程" /><published>2023-04-14T10:28:04+08:00</published><updated>2023-04-14T10:28:04+08:00</updated><id>http://sidgwick.github.io/2023/04/14/meta-programming</id><content type="html" xml:base="http://sidgwick.github.io/2023/04/14/meta-programming.html"><![CDATA[<p>本文讲述了 python 中 class 的一些细节. 包含:</p>

<ol>
  <li>class 定义和 class 对象</li>
  <li>class 实例对象</li>
</ol>

<h1 id="__new__-函数和-__call__-函数"><code class="language-plaintext highlighter-rouge">__new__</code> 函数和 <code class="language-plaintext highlighter-rouge">__call__</code> 函数</h1>

<p>先从简单的开始, 比如以下代码:</p>

<!--more-->

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">hello</span><span class="p">():</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">hello 类</span><span class="sh">'</span><span class="p">)</span>

    <span class="n">a</span> <span class="o">=</span> <span class="sh">'</span><span class="s">aaaa</span><span class="sh">'</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">hello 运行__new__函数</span><span class="sh">'</span><span class="p">)</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">cls</span><span class="sh">"</span><span class="p">,</span> <span class="n">cls</span><span class="p">)</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">args</span><span class="sh">"</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">kwargs</span><span class="sh">"</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">=</span><span class="sh">"</span> <span class="o">*</span> <span class="mi">20</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="nb">object</span><span class="p">.</span><span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">hello 运行__call__函数</span><span class="sh">'</span><span class="p">)</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">self</span><span class="sh">"</span><span class="p">,</span> <span class="n">self</span><span class="p">)</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">args</span><span class="sh">"</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">kwargs</span><span class="sh">"</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">=</span><span class="sh">"</span> <span class="o">*</span> <span class="mi">20</span><span class="p">)</span>


<span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">------ execute -----</span><span class="sh">'</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="nf">type</span><span class="p">(</span><span class="n">hello</span><span class="p">))</span>
<span class="nf">print</span><span class="p">(</span><span class="n">hello</span><span class="p">.</span><span class="n">a</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">A</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">-</span><span class="sh">'</span> <span class="o">*</span> <span class="mi">20</span><span class="p">)</span>
<span class="n">obj</span> <span class="o">=</span> <span class="nf">hello</span><span class="p">(</span><span class="sh">'</span><span class="s">HI</span><span class="sh">'</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">B</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">-</span><span class="sh">'</span> <span class="o">*</span> <span class="mi">20</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">C</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">-</span><span class="sh">'</span> <span class="o">*</span> <span class="mi">20</span><span class="p">)</span>
<span class="nf">obj</span><span class="p">()</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">D</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">-</span><span class="sh">'</span> <span class="o">*</span> <span class="mi">20</span><span class="p">)</span>
</code></pre></div></div>

<p>输出为:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>hello 类
------ execute -----
&lt;class 'type'&gt;
aaaa
A --------------------
hello 运行__new__函数
cls &lt;class '__main__.hello'&gt;
args ('HI',)
kwargs {}
====================
B --------------------
&lt;__main__.hello object at 0x10ee13fd0&gt;
C --------------------
hello 运行__call__函数
self &lt;__main__.hello object at 0x10ee13fd0&gt;
args ()
kwargs {}
====================
D --------------------
</code></pre></div></div>

<p>可以看到在 Python 解释器遇到 <code class="language-plaintext highlighter-rouge">class</code> 定义的时候, 就会执行 class body 中的语句. 当实例化一个类的时候, <code class="language-plaintext highlighter-rouge">__new__</code> 方法被调用, 如果尝试把实例对象作为函数调用, 则会触发 <code class="language-plaintext highlighter-rouge">__call__</code> 函数的调用.</p>

<p>接下来给 <code class="language-plaintext highlighter-rouge">hello</code> 指定一个 <code class="language-plaintext highlighter-rouge">metaclass</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">mclass</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">clsname</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">dct</span><span class="p">):</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">mclass - 运行__new__函数</span><span class="sh">'</span><span class="p">)</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">cls</span><span class="sh">"</span><span class="p">,</span> <span class="n">cls</span><span class="p">)</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">clsname</span><span class="sh">"</span><span class="p">,</span> <span class="n">clsname</span><span class="p">)</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">bases</span><span class="sh">"</span><span class="p">,</span> <span class="n">bases</span><span class="p">)</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">dct</span><span class="sh">"</span><span class="p">,</span> <span class="n">dct</span><span class="p">)</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">=</span><span class="sh">"</span> <span class="o">*</span> <span class="mi">20</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="nf">super</span><span class="p">().</span><span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">clsname</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">dct</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">mclass 对象实例运行__call__函数</span><span class="sh">'</span><span class="p">)</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">args</span><span class="sh">"</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">kwargs</span><span class="sh">"</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">=</span><span class="sh">"</span> <span class="o">*</span> <span class="mi">20</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">self</span>

<span class="k">class</span> <span class="nc">world</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">mclass</span><span class="p">):</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">world class</span><span class="sh">"</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">hello</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">mclass</span><span class="p">):</span>
    <span class="bp">...</span>
</code></pre></div></div>

<p>这次再执行脚本, 输出如下:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>hello 类
mclass - 运行__new__函数
cls &lt;class '__main__.mclass'&gt;
clsname hello
bases ()
dct {'__module__': '__main__', '__qualname__': 'hello', 'a': 'aaaa', '__new__': &lt;function hello.__new__ at 0x10856e3b0&gt;, '__call__': &lt;function hello.__call__ at 0x108622cb0&gt;}
====================
world class
mclass - 运行__new__函数
cls &lt;class '__main__.mclass'&gt;
clsname world
bases ()
dct {'__module__': '__main__', '__qualname__': 'world'}
====================
------ execute -----
&lt;class '__main__.mclass'&gt;
aaaa
A --------------------
mclass 对象实例运行__call__函数
args ('HI',)
kwargs {}
====================
B --------------------
&lt;class '__main__.hello'&gt;
C --------------------
mclass 对象实例运行__call__函数
args ()
kwargs {}
====================
D --------------------
</code></pre></div></div>

<p>可以看到几点不同:</p>

<ol>
  <li>mclass 的 <code class="language-plaintext highlighter-rouge">__new__</code> 在解释器遇到 <code class="language-plaintext highlighter-rouge">world</code> 或者 <code class="language-plaintext highlighter-rouge">hello</code> 类的定义的时候就触发了, 这里应该理解为, 解释器需要使用 metaclass 实例来生成类型对象, 因此就需要在遇到 <code class="language-plaintext highlighter-rouge">metaclass=mclass</code> 时候将 mclass 实例化, 所以 mclass 的 <code class="language-plaintext highlighter-rouge">__new__</code> 函数被触发了 2 次</li>
  <li><code class="language-plaintext highlighter-rouge">hello</code> 类的类型现在变成了 <code class="language-plaintext highlighter-rouge">mclass</code>, 这主要是因为指定了元类之后, 类对象就会使用这个元类生成, 因此类型就不再是 <code class="language-plaintext highlighter-rouge">type</code> 了(<code class="language-plaintext highlighter-rouge">type</code> 本身也是一种元类)</li>
  <li><code class="language-plaintext highlighter-rouge">hello</code> 类实例化的时候, 触发了元类的 <code class="language-plaintext highlighter-rouge">__call__</code> 函数, 等到再次尝试以函数方式调用实例时, 又触发了元类 <code class="language-plaintext highlighter-rouge">__call__</code> 调用.</li>
</ol>

<blockquote>
  <p>TODO: 第三点是为啥?</p>
</blockquote>

<hr />

<p>下面是一段来自 <a href="https://github.com/mementum/backtrader">backtrader</a> 的代码, 在 backtrader 里面有大量的使用, 这里对它做做一些解释.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">with_metaclass</span><span class="p">(</span><span class="n">meta</span><span class="p">,</span> <span class="o">*</span><span class="n">bases</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">Create a base class with a metaclass.</span><span class="sh">"""</span>

    <span class="c1"># This requires a bit of explanation: the basic idea is to make a dummy
</span>    <span class="c1"># metaclass for one level of class instantiation that replaces itself with
</span>    <span class="c1"># the actual metaclass.
</span>    <span class="k">class</span> <span class="nc">metaclass</span><span class="p">(</span><span class="n">meta</span><span class="p">):</span>

        <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">this_bases</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
            <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Creating class </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s"> with metaclass </span><span class="si">{</span><span class="n">metaclass</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
            <span class="k">return</span> <span class="nf">meta</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>

    <span class="k">return</span> <span class="nb">type</span><span class="p">.</span><span class="nf">__new__</span><span class="p">(</span><span class="n">metaclass</span><span class="p">,</span> <span class="nf">str</span><span class="p">(</span><span class="sh">"</span><span class="s">temporary_class</span><span class="sh">"</span><span class="p">),</span> <span class="p">(),</span> <span class="p">{})</span>

</code></pre></div></div>

<p>这个函数用来生成一个类定义, 这个类定义有如下特性:</p>

<ol>
  <li>使用 <code class="language-plaintext highlighter-rouge">type.__new__</code> 来创建类名叫做 temporary_class 的类定义</li>
  <li>这个类的元类是 (metaclass 和 meta), 这两个元类的作用是在 temporary_class 的创建过程中控制创建过程,
(metaclass, meta) 两个元类的 <strong>new</strong> 方法会被先后调用, 以达到控制创建过程的目的</li>
</ol>

<p>看以下代码:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MyMeta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">dct</span><span class="p">):</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Creating class </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s"> with metaclass </span><span class="si">{</span><span class="n">cls</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
        <span class="k">return</span> <span class="nf">super</span><span class="p">().</span><span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">dct</span><span class="p">)</span>


<span class="n">MyClass</span> <span class="o">=</span> <span class="nf">with_metaclass</span><span class="p">(</span><span class="n">MyMeta</span><span class="p">,</span> <span class="nb">object</span><span class="p">)</span>
<span class="c1"># 到这里, `MyClass` 是以 (`with_classmeta.classmeta`, `MyMeta`) 两个元类为元类的类定义
</span>
<span class="k">class</span> <span class="nc">MySubClass</span><span class="p">(</span><span class="n">MyClass</span><span class="p">):</span>
    <span class="sh">'''</span><span class="s">定义一个继承 MyClass 的类</span><span class="sh">'''</span>
    <span class="k">pass</span>
</code></pre></div></div>

<p>在上面 MySubClass 定义过程中, (<code class="language-plaintext highlighter-rouge">with_classmeta.classmeta</code>, <code class="language-plaintext highlighter-rouge">MyMeta</code>) 的 <code class="language-plaintext highlighter-rouge">__new__</code> 函数就会被先后调用</p>]]></content><author><name>Zhigang Song</name></author><category term="python" /><category term="oop" /><category term="meta-programming" /><summary type="html"><![CDATA[本文讲述了 python 中 class 的一些细节. 包含: class 定义和 class 对象 class 实例对象 __new__ 函数和 __call__ 函数 先从简单的开始, 比如以下代码:]]></summary></entry></feed>