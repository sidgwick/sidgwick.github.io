---
title: "GNU Make 中文手册 - 读书笔记"
date: 2016-04-14 14:28:04
tags: c
---

## 第二章

### 相关概念名词

`make` 中的概念: `目标`, `依赖`, `命令行`.

依赖和命令行称为目标的规则, make 程序根据规则依赖关系, 决定是否执行规则所定义的命令行的过程称之为规则执行.

<!--more-->

命令行**必须**以 `Tab` 字符开始, 不过并不是所有的以 `Tab` 开始的行都是命令行.

Make 程序把出现在第一条规则之后的所有以 `Tab` 开始的行, 都当做命令行. --> 这句话有点怪

概念: 伪目标(Phony Targets), 指的是没有依赖只有执行动作的目标

默认情况下, make 执行的是**第一个**遇到的目标规则. 这个目标也称为 `终极目标`

`make` 不对提供给他的 Makefile 里面的规则依赖和命令行合法性最检查(因为它也不知道怎么检查), 它只是简单的执行提供给他的规则信息. 在遇到错误时, `make` 会立即退出并报告错误.

### 2.5 指定变量

使用 `name = ` 的语法来定义变量, 使用的时候使用 `$(name)` 来指代变量值. 比如:

```makefile
objects = main.o \
	display.o

edit: $(objects)
	cc -o edit $(objects)

main.o: main.c main.h
	cc -c main.c -o main.o

display.o: display.c display.h app.h
	cc -c display.c -o display.o

clean:
	rm $(objects)
```

### 2.6 自动推导规则

`make` 自带一个默认的规则(即 `隐含规则`), 能够自动使用 `cc -c` 完成对 `.c` 到 `.o` 文件编译. 在 Makefile 中我们只需要提供 `.o` 目标文件名字, `make` 就会自动的寻找合适的依赖文件, 并编译它.

利用隐含规则, 上面 makefile 现在可以更新为:

```diff
--- a/Makefile
+++ b/Makefile
@@ -4,12 +4,9 @@ objects = main.o \
 edit: $(objects)
 	cc -o edit $(objects)

-main.o: main.c main.h
-	cc -c main.c -o main.o
-
-display.o: display.c display.h app.h
-	cc -c display.c -o display.o
+main.o:
+display.o: app.h

 clean:
-	rm $(objects)
+	rm edit $(objects)
```

### 关于伪目标的说明

1. 可以通过 `.PHONY` 特殊目标将 `clean` 目标声明为伪目标. 如此可以避免当磁盘上存在一个名为 `clean` 文件时, 目标 `clean` 所在规则的命令无法执行
2. 在命令行之前使用 `-` 可以忽略命令 `rm` 的执行错误.

```diff
--- a/Makefile
+++ b/Makefile
@@ -1,6 +1,8 @@
 objects = main.o \
 	display.o

+.PHONY: clean
+
 edit: $(objects)
 	cc -o edit $(objects)

@@ -8,5 +10,4 @@ main.o:
 display.o: app.h

 clean:
-	rm edit $(objects)
+	-rm edit $(objects)
```

## 第三章

### 相关概念名词

`显式规则`, `隐含规则`, `变量定义`, `指示符`, `注释`

- 显式规则: 描述了在何种情况下如何更新一个或者多个被称为目标的文件
- 隐含规则: make 根据一类目标文件(典型的是根据文件名的后缀)而自动推导出来的规则
- 变量定义: 使用一个字符或字符串代表一段文本串, 当定义了一个变量以后, Makefile 后续在需要使用此文本串的地方, 通过引用这个变量来实现对文本串的使用
- Makefile 指示符: 指示符指明在 make 程序读取 makefile 文件过程中所要执行的一个动作. 其中包括:
  – 读取一个文件, 读取给定文件名的文件, 将其内容作为 makefile 文件的一部分.
  – 决定(通常是根据一个变量的得值)处理或者忽略 Makefile 中的某一特定部分
  – 定义一个多行变量
- 注释: Makefile 中 `#` 字符后的内容被作为是注释内容(和 shell 脚本一样)处理. 如果此行的第一个非空字符为`#`, 那么此行为注释行. 注释行的结尾如果存在反斜线(`\`), 那么下一行也被作为注释行.

```diff
--- a/Makefile
+++ b/Makefile
@@ -6,6 +6,9 @@ objects = main.o \
 edit: $(objects)
 	cc -o edit $(objects)

+# This is a comment \
+comment too
+
 main.o:
 display.o: app.h
```

> 奇技淫巧: 利用 make 的隐含规则, 构建 Makefile 里面不存在的目标: `make foo.o`, 将会执行 `cc -c -o foo.o foo.c`

#### 自动变量

- `$^` 代表所有通过目录搜索得到的依赖文件的完整路径名(目录 + 一般文件名)列表
- `$@` 代表规则的目标
- `$<` 代表规则中通过目录搜索得到的依赖文件列表的第一个依赖文件
- `$*` 代表在静态模式规则中匹配到的目标模式的 `茎`
- `$?` 表示依赖文件列表中被改变过的所有文件
- 变量 `CFLAGS` 是编译 `.c` 文件时 gcc 的编译选项, 可以在 Makefile 中给它指定明确的值, 也可以使用隐含的定义值

#### 等于号和他的变种

详细可以参考文章[https://www.cnblogs.com/wanqieddy/archive/2011/09/21/2184257.html](https://www.cnblogs.com/wanqieddy/archive/2011/09/21/2184257.html):

- `=` 是最基本的赋值, make 在整个 makefile 展开之后, 再来决定变量值
- `:=` 是覆盖之前的值, make 在展开过程中, 就决定了变量值
- `?=` 是如果没有被赋值过就赋予等号后面的值
- `+=` 是添加等号后面的值

### 3.3 包含其它 makefile 文件

> 概念: `include` 指示符

在 Makefile 里面可以使用 `include` 包含其他的 Makefile 文件. `make` 在遇到 `include` 语句时, 会暂停当前 Makefile 的读取, 转而去读取被包含的那个(或者多个)文件.

```diff
--- a/Makefile
+++ b/Makefile
@@ -6,6 +6,8 @@ objects = main.o \
 edit: $(objects)
 	cc -o edit $(objects)

+include Makefile.include
+
 # This is a comment \
 comment too

--- /dev/null
+++ b/Makefile.include
@@ -0,0 +1,2 @@
+inc:
+	@echo Hello Include
```

执行 `make inc` 可以看到, `inc` 目标确实被包含了进来.

### 重要的变量(环境变量/内置变量)

`MAKEFILES`: `make` 在正式读取 Makefile 文件之前, 先读取此变量指定的文件的内容, 多用于 `make` 递归调用过程中的通讯

`MAKEFILES_LIST`: `make` 程序在读取多个 makefile 文件时, 包括由环境变量 `MAKEFILES` 指定/命令行指定/当前工作下的默认的以及使用指示符 `include` 指定包含的, 在对这些文件进行解析执行之前 make 读取的文件名将会被自动依次追加到变量 `MAKEFILE_LIST` 的定义域中.

`.VARIABLES` 变量无法通过任何途径赋值, 它由 `make` 自动维护, 他被展开之后是此引用点之前 makefile 文件中所定义的所有全局变量列表. 包括 `空变量(未赋值的变量)` 和 `make 的内嵌变量`, 但不包含目标指定的变量, 目标指定变量值在特定目标的上下文有效.

### 4.3 依赖的类型

`常规依赖` 和 `order-only` 依赖.

```makefile
TARGETS: NORMAL-PREREQUISITES | ORDER-ONLY-PREREQUISITES
```

`order-only` 依赖的特性是, 当 `order-only` 中的依赖文件发生变化的时候, `TARGETS` 不会重新构建.

### 4.4 文件名中使用通配符

Maekfile 中表示文件名时可使用通配符, 可使用的通配符有 `*`, `?`, `[...]`, 在 Makefile 中通配符的用法和含义和 Bash 中完全相同. 不过 Makefile 中这些统配符并不是可以用在任何地方, Makefile 中统配符可以出现在以下两种场合:

1. 可以用在规则的目标, 依赖中. make 在读取 Makefile 时会自动对其进行匹配处理(通配符展开)
2. 可出现在规则的命令中, 通配符的通配处理是在 shell 在执行此命令时完成的

除这两种情况之外的其它上下文中不能直接使用通配符, 而是需要通过函数 `wildcard` 来实现

> 注意: 变量定义中使用的通配符不会被统配处理, 如果需要在变量里面使用通配符, 需要使用 `wildcard` 函数.

```diff
--- a/Makefile
+++ b/Makefile
@@ -1,11 +1,10 @@
-objects = main.o \
-	display.o
+objects := $(patsubst %.c, %.o, $(wildcard *.c))

 .PHONY: clean

 edit: $(objects)
 	cc -o edit $(objects)
-	echo "${.VARIABLES}"
+	@echo *.c

 include Makefile.include

@@ -16,5 +15,7 @@ comment too
 main.o:
 display.o: app.h

+
+
 clean:
 	-rm edit $(objects)
```

### 4.5 目录搜寻

#### 4.5.1 一般搜索(变量 `VPATH`)

通过变量 `VPATH` 可以指定依赖文件的搜索路径, 当规则的依赖文件在当前目录不存在时, make 会在此变量所指定的目录下去寻找这些依赖文件, 其实 `VPATH` 变量所指定的是 Makefile 中所有文件的搜索路径, 包括了规则的依赖文件和目标文件.

定义变量 `VPATH` 时, 使用空格 ` ` 或者冒号 `:` 将多个需要搜索的目录分开. make 搜索目录的顺序是按照变量 `VPATH` 定义中的目录顺序进行的(当前目录永远是第一搜索目录).

```
VPATH = src:../headers
```

比如我们给 `display.[ch]` 创建一个叫做 display 的目录, 把文件移动进去, 使用 `VPATH` 指定这个搜索目录, make 依然能正常的编译得到可执行文件.

```makefile
objects := main.o display.o kbd.o

VPATH = display

.PHONY: clean

edit: $(objects)
	cc -o edit $(objects)
	@echo *.c

main.o: display.h kbd.h app.h
display.o: app.h
kbd.o: app.h

clean:
	-rm edit $(objects)
```

#### 4.5.2 选择性搜索(关键字 `vpath`)

相比 `VPATH` 那么粗粒度的目录指定方式, `vpath` 可以为不同的文件类型指定不同的搜索目录, 使用方法如下:

1. `vpath PATTERN DIRECTORIES` 为所有符合模式 `PATTERN` 的文件指定搜索目录 `DIRECTORIES`, 多个目录使用空格或者冒号分开, 类似上一小节的 `VPATH` 变量
2. `vpath PATTERN` 清除之前为符合模式 `PATTERN` 的文件设置的搜索路径
3. `vpath` 清除所有已被设置的文件搜索路径

比如:

```makefile
vpath %.h ../headers
```

这个例子, 告诉 make `*.h` 文件需要去 `../headers` 文件夹里面寻找.

#### 4.5.6 库文件和搜索目录

Makefile 中程序链接的静态库/共享库同样也可以通过搜索目录得到. 这一特性需要我们在规则的依赖时指定一个类似 `-lNAME` 的依赖文件名, 比如:

```makefile
foo: foo.c -lcurses
	cc $^ -o $@
```

遇到这种依赖文件的时候 make 将:

1. 在执行规则时会在当前目录下搜索一个名字为 `libNAME.so` 的文件
2. 如果当前工作目录下不存在这样一个文件, 则 make 会继续使用 `VPATH` 或者 `vpath` 指定的搜索目录搜索
3. 还是不存在, make 将搜索系统库文件存在的默认目录, 顺序是: `/lib`, `/usr/lib`, `PREFIX/lib`(在 Linux 系统中为 `/usr/local/lib`, 其他的系统可能不同).

如果 `libNAME.so` 通过以上的途径最后还是没有找到的话, 那么 make 将会按照以上的搜索顺序查找名字为 `libNAME.a` 的文件.

在规则的依赖列表中如果出现 `-lNAME` 格式的依赖时, 表示需要搜索的依赖文件名为 `libNAME.so` 和 `libNAME.a`, 这是由变量 `.LIBPATTERNS` 指定的.

`.LIBPATTERNS` 的值一般是多个包含模式字符 `%` 的一个不包含空格的字符串(字), 多个字之间使用空格分开. 在规则中出现 `-lNAME` 格式的依赖时, 首先使用这里的 `NAME` 代替变量 `.LIBPATTERNS` 的第一个字的模式字符而得到第一个库文件名, 根据这个库文件名在搜索目录下查找, 如果能够找到就使用这个文件, 否则使用 `NAME` 代替第二个字的模式字符, 进行同样的查找.

默认情况下 `.LIBPATTERNS` 的值为 `lib%.so lib%.a`. 这也是默认情况下在规则存在 `-lNAME` 格式的依赖时, 链接生成目标时使用 `libNAME.so` 和 `libNAME.a` 的原因.

变量 `.LIBPATTERNS` 就是告诉链接器在执行链接过程中对于出现 `-LNAME` 的文件如何展开, 当然我们也可以将此变量置空, 取消链接器对 `-lNAME` 格式的展开.

### 4.6 伪目标

将一个目标声明为伪目标的方法是将它作为特殊目标 `.PHONY` 的依赖.

使用伪目标有两点原因:

1. 避免在我们的 Makefile 中定义的只执行命令的目标(此目标的目的为了执行执行一些列命令, 而不需要创建这个目标)和工作目录下的实际文件出现名字冲突
2. 提高执行 make 时的效率.

在 make 的并行和递归执行过程中, 此情况下一般会存在一个变量, 定义为所有需要 make 的子目录, 对多个目录进行 make 的实现方式可以是*在一个规则的命令行中使用 shell 循环来完成*, 比如像下面这样:

```makefile
SUBDIRS = foo bar baz
subdirs:
	for dir in $(SUBDIRS); do \
		$(MAKE) -C $$dir; \
	done
```

这种方式是利用 shell 的能力, 逐个处理 subdirs. 如果把这个工作交给 make 处理, 则可以充分利用 make 的并行特性:

```makefile
SUBDIRS = foo bar baz
.PHANY: subdirs $(SUBDIRS)

subdirs: $(SUBDIRS)
$(SUBDIRS):
    $(MAKE) -C $@
foo: bar
```

说明: 通常在清除文件的伪目标所定义的命令中 `rm` 使用选项 `–f(–-force)` 来防止在缺少删除文件时出错并退出, 使 `make clean` 过程失败. 也可以在 `rm` 之前加上 `-` 来防止 `rm` 错误退出, 这种方式时 make 会提示错误信息但不会退出. 另外 make 存在一个内嵌隐含变量 `RM`, 它被定义为: `RM = rm –f`. 因此 在书写 `clean` 规则的命令行时可以使用变量 `$(RM)` 来代替 `rm`.

### 4.7 强制目标(没有命令或依赖的规则)

如果一个规则没有命令或者依赖, 并且它的目标不是一个存在的文件名, 那么在执行此规则时, 目标总会被认为是最新的. 就是说这个规则一旦被执行, make 就认为它的目标已经被更新过. 这 样的目标在作为一个规则的依赖时, 因为依赖总被认为被更新过, 因此作为依赖所在的规则中定义的命令总会被执行.

```makefile
clean: FORCE
    rm $(objects)

FORCE:
```

### 4.8 空目标文件

空目标文件是伪目标的一个变种, 此目标所在规则执行的目的和伪目标相同: 通过 make 命 令行指定将其作为终极目标来执行此规则所定义的命令.

和伪目标不同的是, 这个目标可以是一个存在的文件, 但文件的具体内容我们并不关心, 通常此文件是一个空文件. 空目标文件只是用来记录上一次执行此规则命令的时间. 在这样的规则中, 命令部分都会使用 `touch` 在完成所有命令之后来更新目标文件的时间戳, 记录此规则命令的最后执行时间. make 时通过命令行将此目标作为终极目标, 当前目录下如果不存在这个文件, `touch` 会在第一次执行时创建一个空的文件(命名为空目标文件名).

通常, 一个空目标文件应该存在一个或者多个依赖文件, 将这个目标作为终极目标, 在它所依赖的文件比它新时, 此目标所在规则的命令行将被执行.

```makefile
print: foo.c bar.c
    lpr -p $?
    touch print
```

### 4.9 Makefile 的特殊目标

- `.PHONY`: 目标 `.PHONY` 的所有的依赖被作为伪目标
- `.DEFAULT`: 目标 `.DEFAULT` 所在规则定义的命令, 被用在重建那些没有具体规则的目标(明确规则和隐含规则). 就是说一个文件作为某个规则的依赖, 但却不是另外一个规则的目标 时, Make 程序无法找到重建此文件的规则, 此种情况时就执行 `.DEFAULT` 所指定的命令
- `.PRECIOUS`: 目标 `.PRECIOUS` 的所有依赖文件在 make 过程中会被特殊处理: 当命令在执行过程中被中断时, make 不会删除它们. 而且如果目标的依赖文件是中间过程文件, 同样这些文件不会被删除. 这一点目标 `.PRECIOUS` 和目标 `.SECONDAY` 实现的功能相同. 另外, 目标 `.PRECIOUS` 的依赖文件也可以是一个模式, 例如 `%.o`, 这样可以保留有规则创建的中间过程文件.
- `.INTERMEDIATE`: 目标 `.INTERMEDIATE` 的依赖文件在 make 时被作为中间过程文件对待. 没有任何依赖文件的目标 `.INTERMEDIATE` 没有意义
- `.SECONDARY`: 目标 `.SECONDARY` 的依赖文件被作为中间过程文件对待, 但这些文件不会被自动删除.
- `.DELETE_ON_ERROR`: 如果在 Makefile 中存在特殊目标 `.DELETE_ON_ERROR`, make 在执行过程中, 如果规则的命令执行错误, 将删除已经被修改的目标文件.
- `.IGNORE`: 如果给目标 `.IGNORE` 指定依赖文件, 则忽略创建这个文件所执行命令的错误. 给此目标指定命令是没有意义的. 当此目标没有依赖文件时, 将忽略所有命令执行的错误.
- `.LOW_RESOLUTION_TIME`: 目标 `.LOW_RESOLUTION_TIME` 的依赖文件被 make 认为是低分辨率时间戳文件. 给目标 `.LOW_RESOLUTION_TIME` 指定命令是没有意义的. 通常文件的时间辍都是高分辨率的, make 在处理依赖关系时, 对规则目标-依赖文件的高分辨率的时间戳进行比较, 判断目标是否过期. 但是在系统中并没有提供一个修改文件高分辨率时间辍的机制(方式), 因此类似 `cp -p` 这样的命令在根据源文件创建目的文件时, 所产生的目的文件的高分辨率时间辍的细粒度部分被丢弃(来源于源文件). 这样可能会造成目的文件的时间戳和源文件的相等甚至不及源文件新. 处理此类命令创建的文件时, 需要将命令创建的文件作为目标 `.LOW_RESOLUTION_TIME` 的依赖, 声明这个文件是一个低分辨率时间辍的文件
- `.SILENT`: 出现在目标 `.SILENT` 的依赖列表中的文件, make 在创建这些文件时, 不打印出重建此文件所执行的命令. 没有任何依赖文件的目标 `.SILENT` 告诉 make 在执行过程中不打印任何执行的命令
- `.EXPORT_ALL_VARIABLES`: 此目标应该作为一个简单的没有依赖的目标, 它的功能含义是将之后所有的变量传递给子 make 进程
- `.NOTPARALLEL`: Makefile 中, 如果出现目标 `.NOPARALLEL`, 则所有命令按照串行方式执行, 即使存在 make 的命令行参数 `-j`. 但在递归调用的子 make 进程中, 命令可以并行执行.

所有定义的隐含规则后缀作为目标出现时, 都被视为一个特殊目标, 两个后缀串联起来也是如此, 例如 `.c.o`. 这样的目标被称为**后缀规则的目标**, 这种定义方式是已经过时的定义隐含规则的方法(目前, 这种方式还被用在很多地方). 原则上, 如果将其分为两个部分, 并将它们加到后缀列表中, 任何目标都可采用这种方式来表示. 实际中, 后缀通常以 `.` 开始, 因此, 以上的这些特别目标同样是以 `.` 开始

### 4.10 多目标

一个规则中可以有多个目标, 规则所定义的命令对所有的目标有效. 一个具有多目标的规则相当于多个规则, 规则的命令对不同的目标的执行效果不同, 因为在规则的命令中可能使用了自动环变量`$@`. 多目标规则意味着所有的目标具有相同的依赖文件. 多目标通常用在以下两种情况:

1. 仅需要一个描述依赖关系的规则, 不需要在规则中定义命令. 例如 `kbd.o command.o files.o: command.h` 这个规则实现了同时给三个目标文件指定一个依赖文件.
2. 对于多个具有类似重建命令的目标. 重建这些目标的命令并不需要是完全相同, 因为可以在命令行中使用自动环变量 `$@` 来引用具体的目标, 完成对它的重建.

虽然在多目标的规则中, 可以根据不同的目标使用不同的命令(在命令行中使用自动化变量 `$@`). 但是, 多目标的规则并不能做到根据目标文件自动改变依赖文件(像上边例子中使用自动化变量 `$@` 改变规则的命令一样). 需要实现这个目的是, 要用到 make 的静态模式.

### 4.11 多规则目标

Makefile 中, 一个文件可以作为多个规则的目标(多个规则中只能有一个规则定义命令). 这种情况时, 以这个文件为目标的规则的所有依赖文件将会被合并成此目标一个依赖文件列表, 当其中任何一个依赖文件比目标更新(比较目标文件和依赖文件的时间戳)时, make 将会执行特定的命令来重建这个目标.

对于一个多规则的目标, 重建此目标的命令只能出现在一个规则中(可以是多条命令). 如果多个规则同时给出重建此目标的命令, make 将使用最后一个规则中所定义的命令, 同时提示错误信息某些情况, 需要对相同的目标使用不同的规则中所定义的命令, 我们需要 `双冒号` 规则来实现.

一个仅仅描述依赖关系的述规则可用来给出一个或做多个目标文件的依赖文件. 例如, Makefile 中通常存在一个变量, 就像以前我们提到的 `objects` , 它定义为所有的需要编译生成的 `.o` 文件的列表. 当这些 `.o` 文件在其源文件所包含的头文件 `config.h` 发生变化之后能够自动的被重建, 我们可以使用多目标的方式来书写 Makefile:

```makefile
objects = foo.o bar.o
foo.o : defs.h
bar.o : defs.h test.h
$(objects) : config.h
```

这样做的好处是: 我们可以在源文件增加或者删除了包含的头文件以后不用修改已经存在的 Makefile 的规则, 只需要增加或者删除某一个.o 文件依赖的头文件. 这种方式很简单也很方便. 对于一个大的工程来说, 这样做的好处是显而易见的. 在一个大的工程中, 对于一个单独目录下的 `.o` 文件的依赖规则建议使用此方式. 规则中头文件的依赖描述规则也可以使用 gcc 自动产生.

另外, 我们也可以通过一个变量来增加目标的依赖文件, 使用 make 的命令行来指定某一个目 标的依赖头文件, 例如:

```makefile
extradeps=
$(objects) : $(extradeps)
```

它的意思是: 如果我们执行 `make extradeps=foo.h` 那么 `foo.h` 将作为所有的 `.o` 文件的依赖文件. 当然我们只执行 `make` 的话, 就没有指定任何文件作为 `.o` 文件的依赖文件.

在多规则的目标中, 如果目标的任何一个规则没有定义重建此目标的命令, make 将会寻找一个合适的隐含规则来重建此目标. 关于隐含规则可参考第十章 make 的隐含规则.

### 4.12 静态模式

静态模式规则是这样一个规则: 规则存在多个目标, 并且不同的目标可以根据目标文件的名字来自动构造出依赖文件. 静态模式规则比多目标规则更通用, 它不需要多个目标具有相同的依赖, 但是静态模式规则中的依赖文件必须是相类似的而不是完全相同的.

#### 4.12.1 静态模式规则的语法

首先, 我们来看一下静态模式规则的基本语法:

```makefile
TARGET ... : TAGET-PATTERN : PREREQ-PATTERNS ...
    COMMANDS
    ...
```

`TAGETS` 列出了此规则的一系列目标文件, 像普通规则的目标一样可以包含通配符. `TAGET-PATTERN` 和 `PREREQ-PATTERNS` 说明了如何为每一个目标文件生成依赖文件. 从目标模式(`TAGET-PATTERN`)的目标名字中抽取一部分字符串(称为 `茎` ). 使用 `茎` 替代依赖模式(`PREREQ-PATTERNS`)中的相应部分来产生对应目标的依赖文件. 下边详细介绍这一替代的过程.

首先在目标模式和依赖模式中, 一般需要包含模式字符 `%`. 在目标模式中 `%` 可以匹配目标文件的任何部分, 模式字符 `%` 匹配的部分就是 `茎`. 目标文件和目标模式的其余部分必须精确的匹配. 比如: 目标 `foo.o` 符合模式 `%.o`, 其 `茎` 为 `foo`. 而目标 `foo.c` 和 `foo.out` 就不符合此目标模式.

每一个目标的依赖文件是使用此目标的 `茎` 代替依赖模式(`PREREQ-PATTERNS`)中的模式字符 `%` 而得到. 例如: 上边的例子中依赖模式(`PREREQ-PATTERNS`)为 `%.c`, 那么使用 `茎` `foo` 替代依赖模式中的 `%` 得到的依赖文件就是 `foo.c`.

需要明确的一点是: 在模式规则的依赖列表中使用不包含模式字符 `%` 也是合法的. 代表这个文件是所有目标的依赖文件.

我们来看一个例子, 它根据相应的.c 文件来编译生成 `foo.o` 和 `bar.o` 文件:

```makefile
objects = foo.o bar.o

all: $(objects)

$(objects): %.o: %.c
	$(CC) -c $(CFLAGS) $< -o $@
```

例子中, 规则描述了所有的 `.o` 文件的依赖文件为对应的 `.c` 文件, 对于目标 `foo.o`, 取其茎 `foo` 替代对应的依赖模式 `%.c` 中的模式字符 `%` 之后可得到目标的依赖文件 `foo.c`. 这就是目标 `foo.o` 的依赖关系 `foo.o: foo.c`, 规则的命令行描述了如何完成由 `foo.c` 编译生成目标 `foo.o`. 命令行中 `$<` 和 `$@` 是自动化变量, `$<` 表示规则中的第一个依赖文件, `$@` 表示规则中的目标文件. 上边的这个规则描述了以下两个具体的规则:

```makefile
foo.o: foo.c
	$(CC) -c $(CFLAGS) foo.c -o foo.o

bar.o: bar.c
	$(CC) -c $(CFLAGS) bar.c -o bar.o
```

在使用静态模式规则时, 指定的目标必须和目标模式相匹配, 否则执行 make 时将会得到一个错误提示. 比如上面 `$(objects): %.o: %.c` 如果写成了 `$(objects): %.x: %.c`, 就会因为没有办法匹配合适的依赖文件导致报错.

如果存在一个文件列表, 其中一部分符合某一种模式而另外一部分符合另外一种模式, 这种情况下我们可以使用 `filter` 函数来对这个文件列表进行分类, 在分类之后对确定的某一类使用模式规则. 例如:

```makefile
files = foo.elc bar.o lose.o

$(filter %.o, $(files)): %.o: %.c
	$(CC) -c $(CFLAGS) $< -o $@

$(filter %.elc, $(files)): %.elc: %.el
	emacs -f batch-byte-compile $<
```

其中 `$(filter %.o, $(files))` 的结果为 `bar.o lose.o`. `filter` 函数过滤不符合 `%.o` 模式的文件名而返回所有符合此模式的文件列表. 第一条静态模式规则描述了这些目标文件是通过编译对应的 `.c` 源文件来重建的. 同样第二条规则也是使用这种方式.

我们通过另外一个例子来看一下自动环变量 `$*` 在静态模式规则中的使用方法:

```makefile
bigoutput littleoutput : %output : text.g
	generate text.g -$* > $@
```

当执行此规则的命令时, 自动环变量 `$*` 被展开为 `茎` . 在这里就是 `big` 和 `little`.

静态模式规则对一个较大工程的管理非常有用, 它可以对整个工程的同一类文件的重建规则进行一次定义, 而实现对整个工程中此类文件指定相同的重建规则. 比如, 可以用来描述整个工程中所 有的 `.o` 文件的依赖规则和编译命令. 通常的做法是将生成同一类目标的模式定义在一个 `make.rules` 的文件中. 在工程各个模块的 Makefile 中包含此文件.

#### 4.12.2 静态模式和隐含规则

Makefile 中, **静态模式规则**和被定义为**隐含规则的模式规则**是我们经常使用的两种方式. 两者相同的地方都是用目标模式和依赖模式来构建目标的规则中的文件依赖关系, 两者不同的地方是 make 在执行时使用它们的时机.

隐含规则可被用在任何和它相匹配的目标上, 在 Makefile 中没有为这个目标指定具体的规则, 存在规则但规则没有命令行或者这个目标的依赖文件可被搜寻到. 当存在多个隐含规则和目标模式相匹配时, 只执行其中的一个规则. 具体执行哪一个规则取决于定义规则的顺序.

相反的, 静态模式规则只能用在规则中明确指出的那些文件的重建过程中. 不能用在除此之外的任何文件的重建过程中, 并且它对指定的每一个目标来说是唯一的. 如果一个目标存在于两个规 则, 并且这两个规则都定以了命令, make 执行时就会提示错误.

静态模式规则相比隐含模式规则有以下两个优点:

1. 不能根据文件名通过词法分析进行分类的文件, 我们可以明确列出这些文件, 并使用静态模式规则来重建其隐含规则
2. 对于无法确定工作目录内容, 并且不能确定是否此目录下的无关文件会使用错误的隐含规则而导致 make 失败的情况. 当存在多个适合此文件的隐含规则时, 使用哪一个隐含规则取决于其规则的定义顺序. 这种情况下我们使用静态模式规则就可以避免这些不确定因素, 因为静态模式中, 指定的目标文件有明确的规则来描述其依赖关系和重建命令

### 4.13 双冒号规则

双冒号规则就是使用 `::` 代替普通规则的 `:` 得到的规则. 当同一个文件作为多个规则的目标时, 双冒号规则的处理和普通规则的处理过程完全不同(双冒号规则允许在多个规则中为同一个目标指定不同的重建目标的命令).

> **注意**:
>
> Makefile 中, 一个目标**可以**出现在多个规则中, 但是这这些规则必须是同一类型的规则, 要么都是普通规则, 要么都是双冒号规则. 而不允许一个目标同时出现在两种不同类型的规则中

双冒号规则和普通规则的处理的不同点表现在以下几个方面:

1. 双冒号规则中, 当依赖文件比目标更新时规则将会被执行. 对于一个没有依赖而只有命令行的双冒号规则, 当引用此目标时, 规则的命令将会被无条件执行. 而普通规则, 当规则的目标文件存在时, 此规则的命令永远不会被执行(目标文件永远是最新的). **???**
2. 当同一个文件作为多个双冒号规则的目标时, 这些不同的规则会被独立的处理, 而不是像普通规则那样合并所有的依赖到一个目标文件. 这就意味着对这些规则的处理就像多个不同的普通规则一样. 就是说多个双冒号规则中的每一个的依赖文件被改变之后, make 只执行此规则定义的命令, 而其它的以这个文件作为目标的双冒号规则将不会被执行.

我们来看一个例子, 在我们的 Makefile 中包含以下两个规则:

```makefile
Newprog :: foo.c
	$(CC) $(CFLAGS) $< -o $@

Newprog :: bar.c
	$(CC) $(CFLAGS) $< -o $@
```

如果 `foo.c` 文件被修改, 执行 make 以后将根据 `foo.c` 文件重建目标 `Newprog`. 而如果 `bar.c` 被修改那么 `Newprog` 将根据 `bar.c` 被重建. 回想一下, 如果以上两个规则为普通规时出现的情况是什么? (make 将会出错并提示错误信息).

当同一个目标出现在多个双冒号规则中时, 规则的执行顺序和普通规则的执行顺序一样, 按照其在 Makefile 中的书写顺序执行.

GNU make 的双冒号规则给我们提供一种根据依赖的更新情况而执行不同的命令来重建同一目标的机制. 一般这种需要的情况很少, 所以双冒号规则的使用比较罕见. 一般双冒号规则都需要定义命令, 如果一个双冒号规则没有定义命令, 在执行规则时将为其目标自动查找隐含规则.

### 4.14 自动产生依赖

Makefile 中, 有时要书写一些规则描述一个 `.o` 文件和头文件的依赖关系. 例如, 如果在 `main.c` 中使用 `#include defs.h`, 那么我们可能就需要一个像下边那样的规则来描述当头文件 `defs.h` 被修改以后再次执行 make, 目标 `main.o` 应该被重建.

```makefile
main.o: defs.h
```

这样, 对于一个大型工程就需要在 Makefile 中书写很多条类似于这样的规则. 并且, 当在源文件中加入或删除头文件后, 也需要小心地去修改 Makefile. 这是一件非常费力费时并且危险(容易出错误)的工作. 为了避免这个讨厌的问题, 现代的 c 编译器提供了通过查找源文件中的 `#include` 来自动产生这种依赖关系的功能.

Gcc 通过 `-M` 选项来实现此功能, 使用 `-M` 选项 gcc 将自动找寻源文件中包含的头文件, 并生成文件的依赖关系. 例如, 如果 `main.c` 只包含了头文件 `defs.h`, 那么执行下面的命令(使用 `-MM` 选项可以屏蔽 `-M` 里面输出的标准库头文件):

```bash
gcc -M main.c
```

其输出是:

```makefile
main.o : main.c defs.h
```

在使用 gcc 自动产生依赖关系时, 所产生的规则中明确的指明了目标是 `main.o`. 一次在通过 `.c` 文件直接产生可执行文件时, 作为中间过程文件的 `main.o` 在使用完之后将不会被删除.

在旧版本的 make 中, 使用编译器此项功能通常的做法是在 Makefile 中书写一个伪目标 `depend` 的规则来定义自动产生依赖关系文件的命令. 输入 `make depend` 将生成一个称为 `depend` 的文件, 其中包含了所有源文件的依赖规则描述. Makefile 中使用 `include` 指示符包含这个文件.

在新版本的 make 中, 推荐的方式是为每一个源文件产生一个描述其依赖关系的 makefile 文件. 对于一个源文件 `NAME.c`, 对应的这个 makefile 文件为 `NAME.d`. `NAME.d` 中描述了文件 `NAME.o` 所要依赖的所有头文件. 采用这种方式, 只有源文件在修改之后才会重新使用命令生成新的依赖关系描述文件 `NAME.o`.

我们可以使用如下的模式规则来自动生成每一个 `.c` 文件对应的 `.d` 文件(注意看 sed 把 `%.o, %.d` 文件当做规则的依赖):

```makefile
%.d: %.c
	$(CC) -MM $(CFLAGS) $< > $@.$$$$; \
    sed 's,\($*\)\.o[ :]*,\1.o $@ : ,g' < $@.$$$$ > $@; \
    rm -f $@.$$$$
```

> **注意**:
>
> 注意 sed 里面的自动变量 `$*`, `$@`, `$$$$`, 其中 `$$$$` 代表当前 make 进程号(实际上 shell 执行的是 `$$`, makefile 写法转义了)

使用上例的规则就可以建立一个描述目标文件依赖关系的 `.d` 文件. 我们可以在 Makefile 中使用 `include` 指示符将描述将这个文件包含进来. 在执行 make 时, Makefile 所包含的所有 `.d` 文件就会被自动创建或者更新. Makefile 中对当前目录下 `.d` 文件处理可以参考如下:

```makefile
sources = foo.c bar.c
sinclude $(sources:.c=.d)
```

例子中, 变量 `sources` 定义了当前目录下的需要编译的源文件. 变量引用置换 `$(sources: .c=.d)` 的功能是根据变量 `source` 指定的 `.c` 文件自动产生对应的 `.d` 文件, 并在当前 Makefile 文件中包 含这些 `.d` 文件. `.d` 文件和其它的 makefile 文件一样, make 在执行时读取并试图重建它们. 其实这些 `.d` 文件也是一些可被 make 解析的 makefile 文件.

需要注意的是 `include` 指示符的书写顺序, 因为在这些 `.d` 文件中已经存在规则. 当一个 Makefile 使用指示符 include 这些 `.d` 文件时, 应该注意它应该出现在终极目标之后, 以免 `.d` 文件中的规则被是 Makefile 的终极规则. 关于这个前面我们已经有了比较详细的讨论.

## 第五章 - 规则的命令

### 5.1 命令回显

通常 make 在执行命令行之前会把要执行的命令行输出到标准输出设备. 我们称之为 `回显`, 就好像我们在 shell 环境下输入命令执行时一样. 但是, 如果规则的命令行以字符 `@` 开始, 则 make 在执行这个命令时就不会回显这个将要被执行的命令. 典型的用法是在使用 `echo` 命令输出一些信息时. 如:

```makefile
@echo 开始编译 XXX 模块......
```

执行时, 将会得到 `开始编译 XXX 模块......` 这条输出信息. 如果在命令行之前没有字符 `@`, 那么, make 的输出将是:

```text
echo 开始编译 XXX 模块......
开始编译 XXX 模块......
```

另外, 如果使用 make 的命令行参数 `-n` 或 `--just-print`, 那么 make 执行时只显示所要执行的命令, 但不会真正的去执行这些命令. 只有在这种情况下 make 才会打印出所有 make 需要执行的命令, 其中也包括了使用 `@` 字符开始的命令. 这个选项对于我们调试 Makefile 非常有用, 使用这个选项我们可以按执行顺序打印出 Makefile 中所有需要执行的所有命令.

而 make 参数 `-s` 或 `--slient` 则是禁止所有执行命令的显示, 就好像所有的命令行均使用 `@` 开始一样. 在 Makefile 中使用没有依赖的特殊目标 `.SILENT` 也可以禁止命令的回显, 但是它不如使用 `@` 来的灵活. 因此在书写 Makefile 时, 我们推荐使用 `@` 来控制命令的回显.

### 5.2 命令的执行

规则中, 当目标需要被重建时. 此规则所定义的命令将会被执行, 如果是多行命令, 那么**每一行命令将在一个独立的子 shell 进程中被执行**(就是说, 每一行命令的执行是在一个独立的 shell 进程中完成). 因此, 多行命令之间的执行是相互独立的, 相互之间不存在依赖(多条命令行的执行为多个相互独立的进程).

在 Makefile 中书写在同一行中的多个命令属于一个完整的 shell 命令行, 书写在独立行的一条命令是一个独立的 shell 命令行. 因此: 在一个规则的命令中, 命令行 `cd` 改变目录不会对其后的命令的执行产生影响. 就是说其后的命令执行的工作目录不会是之前使用 `cd` 进入的那个目录. 如果要实现这个目的, 就不能把 `cd` 和其后的命令放在两行来书写. 而应该把这两条命令写在一行上, 用分号分隔. 这样它们才是一个完整的 shell 命令行. 如:

```makefile
foo : bar/lose
	cd bar; gobble lose > ../foo
```

如果希望把一个完整的 shell 命令行书写在多行上, 需要使用反斜杠 `\` 来对处于多行的命令进行连接, 表示他们是一个完整的 shell 命令行. 例如上例我们以也可以这样书写:

```makefile
foo : bar/lose
	cd bar \
    gobble lose > ../foo
```

make 对所有规则命令的解析使用环境变量 `SHELL` 所指定的那个程序, 在 GNU make 中, 默认的程序是 `/bin/sh`.

不像其他绝大多数变量, 它们的值可以直接从同名的系统环境变量那里获得. make 的环境变量 `SHELL` 没有使用系统环境变量的定义. 因为系统环境变量 `SHELL` 指定那个程序被用来作为用户和系统交互的接口程序, 它对于不存在直接交互过程的 make 显然不合适. 在 make 的环境变量中 `SHELL` 会被重新赋值. 它作为一个变量我们也可以在 Makefile 中明确地给它赋值(指出解释程序的名字, 当明确指定时需要使用完整的路径名. 如 `/bin/sh`).

### 5.3 并发执行命令

GNU make 支持同时执行多条命令.

通常情况下, 同一时刻只有一个命令在执行, 下一个命令只有在当前命令执行完成之后才能够开始执行. 不过可以通过 make 的命令行选项 `-j` 或者 `--job` 来告诉 make 在同一时刻可以允许多条命令同时被执行(注意, 在 MS-DOS 中此选项无效, 因为它是单任务操作系统).

如果选项 `-j` 之后存在一个整数, 其含义是告诉 make 在同一时刻可允许同时执行命令的数目. 这个数字被称为 `job slots`. 当 `-j` 选项之后没有出现一个数字时, 那么同一时刻执行的命令数目没有要求. 使用默认的 `job slots`, 值为 1, 表示 make 将串行的执行规则的命令(同一时 刻只能有一条命令被执行).

并行执行命令所带来的问题是显而易见的:

1. 多个同时执的命令的输出信息将同时被输出到终端. 当出现错误时很难根据一大堆凌乱的信 息来区分是哪条命令执行错误.
2. 在同一时刻可能会存在多个命令执行进程同时读取标准输入, 但是对于标准输入设备来说, 在同一时刻只能存在一个进程访问它. 就是说在某个时间点, make 只能保证此刻正在执行的进程中的一个进程读取标准输入流, 而其它进程的标准输入流将置无效. 因此在一时刻多个执行命令的进程中只能有一个进程获得标准输入, 而其它需要读取标准输入流的进程由于输入流无效而导致致命错误(通常此进程会得到操作系统的管道破裂信号而被终止).

   这是因为: 执行中的命令在什么时候会读取标准输入流(终端输入或重定向的标准输入)是不可预测的. 而得到标准输入的顺序总是按照先来先获得的原则. 那个命令首先被执行, 那么它就可以首先得到标准输入设备. 而其它后续需要获取标准输入设备的命令执行进程, 由于不能得到标准输入而产生致命错误. 在 Makefile 规则中如果存在很多命令需要读取标准输入设备, 而它们又被允许并行执行时, 就会出现这样的错误. 为了解决这个问题. 我们可以修改 Makefile 规则的命令使之在执行过程中避免使用标准输入. 当然也可以只存在一个命令在执行时会访问标准输入流的 Makefile.

3. 会导致 make 的递归调用出现问题.

当 make 在执行命令时, 如果某一条命令执行失败(被一个信号中止, 或非零退出), 且该条命令产生的错误不可忽略, 那么其它的用于重建同一目标的命令执行也将会被终止. 此种情况下, 如果 make 没有使用 `-k` 或 `--keep-going` 选项, make 将停止执行而退出. 另外如果 make 在执行时, 由某种原因(包括信号)被中止, 此时它的子进程(那些执行规则命令行的 shell 子进程)正在运行, 那么 make 将等到所有这些子进程结束之后才真正退出.

执行 make 时, 如果系统运行于重负荷状态下, 我们需要控制(减轻)系统在执行 make 时的 负荷. 可以使用 `-l` 选项告诉 make 限制当前运行的任务的数量(make 所限制的只是它本身所需 要占用的系统负载, 而不能通过它去控制其它的任务所占用的系统负载). `-l` 或 `--max-load` 选 项一般后边需要跟一个浮点数. 如 `-l 2.5`, 它的意思是告诉 make 当系统平均负荷高于 2.5 时, 不再启动任何执行命令的子任务. 不带浮点数的 `-l` 选项用于取消前面通 `-l` 给定的负荷限制. 更为准确一点就是, 每一次 make 在启动一项任务之前(当前系统至少存在 make 的子任务正在运行), 首先 make 会检查当前系统的负荷, 如果当前系统的负荷高于通过 `-l` 选项指定的值, 那么 make 就不会在其他任务完成之前启动任何任务. 缺省情况下没有负荷限制.

### 5.4 命令执行的错误

通常规则中的命令在运行结束后, make 会检测命令执行的返回状态, 如果返回成功, 那么就启动另外一个子 shell 来执行下一条命令. 规则中的所有命令执行完成之后, 这个规则就执行完成了. 如果一个规则中的某一个命令出错(返回非 0 状态), make 就会放弃对当前规则后续命令的执行, 也有可能会终止所有规则的执行.

一些情况下, 规则中一个命令的执行失败并不代表规则执行的错误. 例如我们使用 `mkdir` 命令来确保存在一个目录. 当此目录不存在使我们就建立这个目录, 当目录存在时那么 `mkdir` 就会执行失败. 其实我们并不希望 mkdir 在执行失败后终止规则的执行. 为了忽略一些无关命令执行失败的情况, 我们可以在命令之前加一个减号 `-` (在 `Tab` 字符之后), 来告诉 make 忽略此命令的执行失败. 命令中的 `-` 号会在 shell 解析并执行此命令之前被去掉, shell 所解释的只是纯粹的命令, `-` 字符是由 make 来处理的. 例如对于 `clean` 目标我们就可以这么写:

```makefile
clean:
	-rm edit $(objects) *.d
```

其含义是: 即使执行 `rm` 删除文件失败, make 也继续执行.

在执行 make 时, 如果使用命令行选项 `-i` 或者 `—ignore-errors`, make 将忽略所有规则中命令执行的错误. 没有依赖的特殊目标 `.IGNORE` 在 Makefile 中有同样的效果. 但是 `.IGNORE` 的方式已经很少使用, 因为它没有在命令行之前使用 `-` 的方式灵活.

当使用 make 的 `-i` 选项或者使用 `-` 字符来忽略命令执行的错误时, make 始终把命令的执行结果作为成功来对待. 但会提示错误信息, 同时提示这个错误被忽略.

当不使用这种方式来通知 make 忽略命令执行的错误时, 那么在错误发生时, 就意味着定义这个命令规则的目标不能被正确重建, 同样地, 和此目标相关的其它目标也不会被正确重建. 由于先决条件不能建立, 那么后续的命令将不会被执行.

在发生这样情况时, 通常 make 会立刻退出并返回一个非 0 状态, 表示执行失败. 像对待命令执行的错误一样, 我们可以使用 make 的命令行选项 `-k` 或者 `--keep-going` 来通知 make, 在出现错误时不立即退出, 而是继续后续命令的执行. 直到无法继续执行命令时才异常退出. 例如使用 `-k` 参数, 在重建一个 `.o` 文件目标时出现错误, make 不会立即退出, 虽然 make 已经知道因为这个错误而无法完成终极目标的重建, 但还是继续完成其它后续的依赖文件的重建. 直到执行最后链接时才错误退出.

一般 make 的 `-k` 参数在实际应用中, 主要用于当同时修改了工程中的多个文件后, `-k` 参数可以帮助我们确认对那些文件的修改是正确的(可以被编译), 那些文件的修改是不正确的(不能正确编译). 例如我们修改了工程中的 20 个源文件, 修改完成之后使用带 `-k` 参数的 make, 它可以一次性找出修改的 20 个文件中哪些是不能被编译.

通常情况下, 执行失败的命令一旦改变了它所在规则的目标文件, 则这个改变了的目标可能就不是一个被正确重建的文件. 但是这个文件的时间戳已经被更新过了(这种情况也会发生在使用一个信号来强制中止命令执行的时候). 因此下一次执行 make 时, 由于时间戳更新它将不会被重建, 将最终导致终极目标不能被正确重建. 为了避免这种错误的出现, 应该在一次 make **执行失败之后** 使用 `make clean` 来清除已经重建的所有目标, 之后再执行 make. 我们也可以让 make 自动完成这个动作, 我们只需要在 Makefile 中定义一个特殊的目标 `.DELETE_ON_ERROR`. 但是这个做法存在不兼容. 推荐的做法是在 make 执行失败时, 修改错误之后执行 make 之前, 使用 `make clean` 明确的删除第一次错误重建的所有目标.

本节的最后, 需要说明的是, 虽然 make 提供了命令行选项来忽略命令执行的错误. 建议对于此选项谨慎使用. 因为在一个大型的工程中, 可能需要对成千个源文件进行编译. 编译过程中的任何一个文件编译的错误都是不能被忽略的, 否则可能最后完成的终极目标是一个让你感到非常迷惑的东西, 它在运行时可能会产生一些莫名奇妙的现象. 这需要我们保证书写的 Makefile 中规则的命令在执行时不会发生错误. 特别需要注意哪些有特殊目的的规则中的命令.

当所有命令都可以被正确执行时, 我们就没有必要为了避免一些讨厌的错误而使用 `-i` 选项, 为了实现同样的目的, 我们可以使用其它的一些方式. 例如删除命令可以这样写: `$(RM)` 或者 `rm -f`, 创建目录的命令 可以这样写: `mkdir --p` 等等

### 5.5 中断 make 的执行

make 在执行命令时如果收到一个致命信号(终止 make), 那么 make 将会删除此过程中已经重建的那些规则的目标文件. 其依据是此目标文件的当前时间戳和 make 开始执行时此文件的时间戳是否相同.

> TODO: 上面不是说不会删除吗? 是说收到的信号不同处理方式不同???

删除这个目标文件的目的是为了确保下一次 make 时目标文件能够被正确重建. 其原因我们上一节已经有所讨论. 假设正在编译时键入 `Ctrl-c`, 此时编译器已经开始写文件 `foo.o`, 但是 `Ctrl-c` 产生的信号关闭了编译器. 这种情况下文件 `foo.o` 可能是不完整的, 但这个内容不完整的 `foo.o` 文件的时间戳比源程序 `foo.c` 的时间戳新. 如果在 make 收到终止信号后不删除文件 `foo.o` 而直接退出, 那么下次执行 make 时此文件被认为已是最新的而不会去重建它. 最后在链 接生成终极目标时由于某一个 `.o` 文件的不完整, 可能出现一堆令人难以理解的错误信息, 或者产生了一个不正确的终极目标.

相反, 可以在 Makefile 中将一个目标文件作为特殊目标 `.PRECIOUS` 的依赖, 来取消 make 在重建这个目标时, 在异常终止的情况下对这个目标文件的删除动作. 每一次在 make 在重建一个目标之前, 都将首先判断该目标文件是否出现在特殊目标 `.PRECIOUS` 的依赖列表中, 决定在终止信号发生时是否要删除这个目标文件. 不删除这种目标文件的原因可能是:

1. 目标的重建动作是一个原子的不可被中断的过程
2. 目标文件的存在仅仅为了记录其重建时间(不关心其内容无)
3. 这个目标文件必须一直存在来防止其它麻烦

### 5.6 make 的递归执行

make 的递归过程指的是在 Makefile 中使用 `make` 作为一个命令来执行本身或者其它 makefile 文件的过程.

递归调用在一个存在有多级子目录的项目中非常有用. 例如当前目录下存在一个 `subdir` 子目录, 在这个子目录中有描述此目录编译规则的 makefile 文件, 在执行 make 时需要从上层目录(当前目录)开始并完成它所有子目录的编译. 那么在当前目录下可以使用这样一个规则来实现对这个子目录的编译:

```makefile
subsystem:
	cd subdir && $(MAKE)
```

其等价于规则:

```makefile
subsystem:
	$(MAKE) -C subdir
```

对这两个规则的命令进行简单说明, 规则中 `$(MAKE)` 是对变量 `MAKE` 的引用(下一小节将详细讨论 `MAKE`, 关于变量可参考第六章 Makefile 中的变量). 第一个规则命令的意思是进入子目录, 然后在子目录下执行 make. 第二个规则使用了 make 的 `-C` 选项, 同样是首先进入子目录 而后再执行 make.

书写这样的规则对于我们来说应该不是什么大问题, 但是其中有一些需要我们深入了解的东西, 首先需要了解它如何工作, 上层 make(在当前目录下运行的 make 进程)和下层 make(subdir 目录下运行的 make 进程)之间存在的联系. 也许会发现这两个规则的实现, 使用伪目标更能提高效率.

在 make 的递归调用中, 需要了解一下变量 `CURDIR`, 此变量代表 make 的工作目录. 当使用 `-C` 选项进入一个子目录后, 此变量将被重新赋值. 总之, 如果在 Makefile 中没有对此变量进行显式的赋值操作, 那么它代表 make 的工作目录. 我们也可以在 Makefile 为这个变量赋一个新的值. 此时这变量将不再代表 make 的工作目录.

#### 5.6.1 变量 MAKE

在使用 make 的递归调用时, 在 Makefile 规则的命令行中应该使用变量 `MAKE` 来代替直接使用 `make`. 上一小节的例子应该这样来书写:

```makefile
subsystem:
	cd subdir && $(MAKE)
```

变量 `MAKE` 的值是 `make`. 如果其值为 `/bin/make` 那么上边规则的命令就为 `cd subdir && /bin/make`. 这样做的好处是:当我们使用一个其它版本的 make 程序时, 可以保证最上层使 用的 make 程序和其子目录下执行的 make 程序保持一致.

> **注意**:
> 下面的 `-t` 选项用来更新所有目标的时间戳, 而不执行任何规则的命令.

另外使用此变量的另外一个特点是: 当规则命令行中变量 MAKE 时, 可以改变 make 的 `-t` ( `--touch` ), `-n` ( `--just-print` )和 `-q` ( `--question` )命令行选项的效果. 它所实现的功能和在规则中命令行首使用字符 `+` 的效果相同. 在规则的命令行中使用 `make` 代替了 `$(MAKE)` 以后, 上例子规则的命令行为 `cd subdir && make`. 在我们执行 `make -t`, 结果是仅仅创建一个名为 `subsystem` 的文件, 而不会进入到目录 `subdir` 去更新此目录下文件的时间戳. 我们使用`-t`命令行参数的初衷是对规则中的目标文件的时间戳进行更新. 而如果使 `cd subdir && $(MAKE)` 作为规则的命令行, 执行 `make -t` 就可以实现我们的初衷

变量`MAKE`的这个特点是: 在规则的命令行中如果使用变量 `MAKE`, 标志 `-t`, `-n` 和 `-q` 在这个命令的执行中不起作用. 尽管这些选项是告诉 make 不执行规则的命令行, 但包含变量 `MAKE` 的命令行除外, 它们会被正常执行. 同时, 执行 make 的命令行选项参数被通过一个变量 `MAKEFLAGS` 传递给子目录下的 make 程序.

例如, 当使用 make 的命令行选项 `-t` 来更新目标的时间戳或者 `-n` 选项打印命令时, 这些选项将会被赋值给变量 `MAKEFLAGS` 被传递到下一级的 make 程序中. 在下一级子目录中执行的 make, 这些选项会被附加作为 make 的命令行参数来执行, 和在此目录下使用 `make -t` 或者 `make -n` 有相同的效果.

### 5.7 变量和递归

在 make 的递归执行过程中, 上层 make 可以明确指定将一些变量的定义通过环境变量的方式传递给子 make 过程. 没有明确指定需要传递的变量, 上层 make 不会将其所执行的 Makefile 中定义的变量传递给子 make 过程. 使用环境变量传递上层所定义的变量时, 上层所传递给子 make 过程的变量定义不会覆盖子 make 过程所执行 makefile 文件中的同名变量定义.

如果子 make 过程所执行 Makefile 中存在同名变量定义, 则上层传递的变量定义不会覆盖子 Makefile 中定义的值. 就是说如果上层 make 传递的变量和子 make 所执行的 Makefile 中存在重复 的变量定义, 则以子 Makefile 中的变量定义为准. 除非使用 make 的 `-e` 选项.

我们在本节第一段中提到, 上层 make 过程要将所执行的 Makefile 中的变量传递给子 make 过程, 需要明确地指出. 在 GNU make 中, 实现此功能的指示符是 `export`. 当一个变量使用 `export` 进行声明后, 变量和它的值将被加入到当前工作的环境变量中, 以后在 make 执行的所有规则的命令都可以使用这个变量. 而当没有使用指示符 `export` 对任何变量进行声明的情况下, 上层 make 只将那些已经初始化的环境变量(在执行 make 之前已经存在的环境变量)和使用命令行指定的变量(如命令 `make CFLAGS +=-g` 或者 `make --e CFLAGS +=-g` )传递给子 make 程序, 通常这些变量由字符, 数字和下划线组成. 需要注意的是有些 shell 不能处理那些名字中包含除字母/数字/下划线以外的其他字符的变量.

存在两个特殊的变量 `SHELL` 和 `MAKEFLAGS`, 对于这两个变量除非使用指示符 `un-export` 对它们进行声明, 它们在整个 make 的执行过程中始终被自动的传递给所有的子 make. 另外一个变量 `MAKEFILES`, 如果此变量有值(不为空)那么同样它会被自动的传递给子 make. 在没有使用关键字 `export` 声明的变量, make 执行时它们不会被自动传递给子 make, 因此下层 Makefile 中可以定义和上层同名的变量, 不会引起变量定义冲突.

需要将一个在上层定义的变量传递给子 make, 应该在上层 Makefile 中使用指示符 `export` 对此变量进行声明. 当不希望将一个变量传递给子 make 时, 可以使用指示符 `unexport` 来声明这个变量. 他们的格式如下:

```makefile
export VARIABLE ...
unexport VARIABLE ...
```

以上两种格式, 指示符 `export` 或者 `unexport` 的参数(变量部分), 如果它是对一个变量或者函数的引用, 这些变量或者函数将会被立即展开. 并赋值给 export 或者 unexport 的变量(关于变量展开的过程可参考第六章 Makefile 中的变量). 例如:

```makefile
Y=Z
export X=$(Y)
```

其实就是 `export X=Z`. export 时对变量进行展开, 是为了保证传递给子 make 的变量值有效(使用当前 Makefile 中定义的变量值).

`export` 更方便的用法是在定义变量的同时对它进行声明. 看下边的几个例子:

- 例 1

  ```makefile
  export VARIABLE = value
  ```

  等效于:

  ```makefile
  VARIABLE = value
  export VARIABLE
  ```

- 例 2

  ```makefile
  export VARIABLE := value
  ```

  等效于:

  ```makefile
  VARIABLE := value
  export VARIABLE
  ```

- 例 3

  ```makefile
  export VARIABLE += value
  ```

  等效于:

  ```makefile
  VARIABLE += value
  export VARIABLE
  ```

> 还记得 `=`, `:=`, `+=` 的区别吗?

我们可以看到, 其实在 Makefile 中指示符 `export` 和 `unexport` 的功能和在 shell 下功能基本相同.

一个不带任何参数的指示符 `export` 指示符含义是将此 Makefile 中定义的所有变量传递给子 make 过程. 如果不需要传递其中的某一个变量, 可以单独使用指示符 `unexport` 来声明这个变量. 使用 `export` 将所有定义的变量传递给子 Makefile 时, 那些名字中包含其它字符(除字母/数字和下划线以外的字符)的变量可能不会被传递给子 make, 对这类特殊命名的变量传递需要明确的使用 `export` 指示符对它进行声明. 虽然不带任何参数的 `export` 指示符具有特殊的含义, 但是一个不带任何参数的 `unexport` 指示符却是没有任何意义的, 它不会对 make 的执行过程(变量的传递)产生任何影响.

#### 5.7.1 命令行选项和递归

在 make 的递归执行过程中. 最上层(可以称之为主控)make 的命令行选项 `-k` 、 `-s` 等会被自动的通过环境变量 `MAKEFLAGS` 传递给子 make 进程. 传递过程中变量 `MAKEFLAGS` 的值会被主控 make 自动的设置为包含执行 make 时的命令行选项的字符串. 如果在执行 make 时通过命令行指定了 `-k` 和 `-s` 选项, 那么 `MAKEFLAGS` 的值会被自动设置为 `ks`. 子 make 进程在处理时, 会把此环境变量的值作为执行的命令行参数, 因此子 make 过程同样也会有 `-k` 和 `-s` 这两个命令行选项.

同样, 执行 make 时命令行中给定的一个变量定义(如 `make CFLAGS+=-g`), 此变量和它的值(`CFLAGS+=-g`)也会借助环境变量 `MAKEFLAGS` 传递给子 make 进程. 可以借助 make 的环境变量 `MAKEFLAGS` 传递我们在主控 make 所使用的命令行选项给子 make 进程. 需要注意的是有几个特殊的命令行选项例外, 他们是: `-C` 、 `-f` 、 `-o` 和 `-W`. 这些命令行选项是不会被赋值给变量 `MAKEFLAGS` 的.

Make 命令行选项中一个比较特殊的是 `-j` 选项. 在支持这个选项的操作系统上, 如果给它指定了一个数值 `N` (多任务的系统 unix、Linux 支持, MS-DOS 不支持), 那么主控 make 和子 make 进程会在执行过程中使用通信机制来限制系统在同一时刻(包括所有的递归调用的 make 进程, 否则, 将会导致 make 任务的数目数目无法控制而使别的任务无法到的执行)所执行任务的数目不大于 `N`. 另外, 当使用的操作系统不能支持 make 执行过程中的父子间通信, 那么无论在执行主控 make 时指定的任务数目 `N` 是多少, 变量 `MAKEFLAGS` 中选项 `-j` 的数目会都被设置为 `1`, 通过这样来确保系统的正常运转.

执行多级的 make 调用时, 当不希望传递 `MAKEFLAGS` 的给子 make 时, 需要在调用子 make 是对这个变量进行赋空.

```makefile
subsystem:
    cd subdir && $(MAKE) MAKEFLAGS=
```

执行 make 时可以通过命令行来定义一个变量, 像上例中的那样. 前边已经提到过, 这种变量是借助环境 `MAKEFLAGS` 来传递给多级调用的子 make 进程的. 其实真正的命令行中的变量定义是通过另外一个变量 `MAKEOVRRIDES` 记录的, 在变量 `MAKEFLAGS` 的定义中引用了此变量, 所以命令行中的变量定义被记录在环境变量 `MAKEFLAGS` 中被传递下去. 当不希望上层 make 在命令行中定义的变量传递给子 make 时, 可以在上层 Makefile 中把 `MAKEOVERRIDES` 赋空(`MAKEOVERRIDES=`). 但是这种方式通常很少使用, 建议非万不得已您还是最好不使用这种方式(为了和 POSIX2.0 兼容, 当 Makefile 中出现 `.POSIX` 这个特殊的目标时, 在上层 Makefile 中修改变量 `MAKEOVERRIDES` 对子 make 不会产生任何影响). 另外, 在一些系统中环境变量值的长度存在一个上限, 因此当 `MAKEFLAGS` 的值超过一定长度时, 执行过程可能会出现类 似 `Arg list too long` 的错误提示.

在某些特殊的场合, 可能需要为所有的 make 进程指定一个统一的命令行选项. 比如说需要给所有的运行的 make 指定 `-k` 选项. 实现这个目的, 我们可以在执行 make 之前设置一个系统环境变量(存在于当前系统的环境中) `MAKEFLAGS=k`, 或者在主控 Makefile 中将它的值赋为 `k`.

make 在执行时, 首先将会对变量 `MAKEFLAGS` 的值(系统环境中或者在 Makefile 中设置的)进行分析. 当变量的值不是以连字符(`-`)开始时, 将变量的值按字分开, 字之间使用空格分开. 将这些字作为命令行的选项对待(除了选项 `-C` 、 `-f` 、 `-h` 、 `-o` 和 `-W` 以及他们的长格式, 如果其中包含无效的选项不会提示错误).

最后需要说明的是, 将 `MAKEFLAGS` 设置为系统环境变量的做法是不可取的! 因为这样一旦将一些调试选项或者特殊选项作为此变量值的一部分, 在执行 make 时, 会对 make 的正常执行产生潜在的影响. 例如如果变量 `MAKEFLAGS` 中包含选项 `t` 、 `n` 、 `q` 这三个的任何一个, 当执行 make 的结果可能就不是你所要的. 建议大家最好不要随便更改 `MAKEFLAGS` 的值, 更不要把它设置为系统的环境变量来使用. 否则可能会产生一些奇怪甚至让你感到不解的现象

#### 5.7.2 -w 选项

在多级 make 的递归调用过程中, 选项 `-w` 或者 `--print-directory` 可以让 make 在开始编译一个目录之前和完成此目录的编译之后给出相应的提示信息, 方便开发人员跟踪 make 的执行过 程. 例如在目录 `/u/gnu/make` 目录下执行 `make -w` , 将会看到如下的一些信息: 在开始执行之前我们将看到:

```text
make: Entering directory `/u/gnu/make'.
```

而在完成之后我们同样将会看到:

```text
make: Leaving directory `/u/gnu/make'.
```

通常, 选项 `-w` 会被自动打开. 在主控 Makefile 中当如果使用 `-C` 参数来为 make 指定一个目录或者使用 `cd` 进入一个目录时, `-w` 选项会被自动打开. 主控 make 可以使用选项 `-s` ( `--slient` )来禁止此选项. 另外, make 的命令行选项 `--no-print-directory`, 将禁止所有关于目录 信息的打印.

### 5.8 定义命令包

书写 Makefile 时, 可能有多个规则会使用相同的一组命令. 就像 c 语言程序中需要经常使用到函数 `printf`. 这时我们就会想能不能将这样一组命令进行类似 c 语言函数一样的封装, 以后在我们需要用到的地方可以通过它的名字(c 语言中的函数名)来对这一组命令进行引用. 这样就可减少重复工作, 提高了效率. 在 GNU make 中, 可以使用指示符 `define` 来完成这个功能. 通过 `define` 来定义这样一组命令, 同时用一个变量(作为一个变量, 不能和 Makefile 中其它常规的变量命名出现冲突)来代表这一组命令. 通常我们把使用 `define` 定义的 一组命令称为一个命令包. 定义一个命令包的语法以 `define` 开始, 以 `endef` 结束, 例如:

```makefile
define run-yacc
yacc $(firstword $^)
mv y.tab.c $@
endef
```

这里 `run-yacc` 是这个命令包的名字. 在 `define` 和 `endef` 之间的命令就是命令包的主体. 需要说明的是, 使用 `define` 定义的命令包中, 命令体中变量和函数的引用不会展开. 命令体中所有的内容包括 `$` 、 `(` 、 `)` 等都是变量 `run-yacc` 的定义. 它和 c 语言中宏的使用方式一样. 关于变量可参考第六章 Makefile 中的变量.

例子中, 命令包中第一个命令是对引用它所在规则中的第一个依赖文件运行 yacc 程序. yacc 程序总是生成一个命名为 `y.tab.c` 的文件. 第二行的命令就是把这个文件名改为规则目标的名字.

定义了这样一个命令包后, 后续应该如何使用它?前面已经提到, 命令包是使用一个变量来表示的. 因此我们就可以按使用变量的方式来使用它. 当在规则的命令行中使用这个变量时, 命令包 所定义的命令体就会对它进行替代. 由于使用 `define` 定义的变量属于递归展开式变量, 因此, 命令包中所有命令中对其它变量的引用, 在规则被执行时会被完全展开. 例如这样一个规则:

```makefile
foo.c :
	foo.y $(run-yacc)
```

此规则在执行时, 我们来看一下命令包中的变量的替换过程:

1. 命令包中的 `$^` 会被 `foo.y` 替 换;
2. `$@` 被 `foo.c` 替换.

当在一个规则中引用一个已定义的命令包时, 命令包中的命令体会被原封不动的展开在引用它的地方(和 c 语言中的宏一样). 这些命令就成为规则的命令. 因此我们也可在定义命令包时使用前缀来控制单独的一个命令行(例如 `@` , `-` 和 `+` ). 例如:

```makefile
define frobnicate
    @echo "frobnicating target $@"
    frob-step-1 $< -o $@-step-1
    frob-step-2 $@-step-1 -o $@
endef
```

此命令包的第一行命令执行前不会被回显, 其它的命令在执行前都被回显.

另一方面, 如果一个规则在引用此命令包之前使用了控制命令的前缀字符. 那么这个前缀字符
将会被添加到命令包定义的每一个命令行之中. 例如:

```makefile
frob.out:
    frob.in @$(frobnicate)
```

这个规则执行时不会回显任何要执行的命令.

### 5.9 空命令

有时可能存在这样的一个需求, 需要定义一个什么也不做的规则(不需要任何执行的命令). 前面已经有过这样的用法. 这样的规则, 只有目标文件(可以存在依赖文件)而没有命令行. 像这样定义:

```makefile
target: ;
```

这就是一个空命令的规则, 为目标 `target` 定义了一个空命令. 也可以使用独立的命令行格式来定义, 需要注意的是独立的命令行必须以 `Tab` 字符开始. 一般在定义空命令时, 建议不使用命令行的方式, 因为看起来空命令行和空行在感觉上没有区别.

大家会奇怪为什么要定义一个没有命令的规则. 其唯一的原因是, 空命令行可以防止 make 在执行时试图为重建这个目标去查找隐含命令(包括了使用隐含规则中的命令和 `.DEFAULT` 指定的命令. 关于隐含规则可参考第十章使用隐含规则), 这一点它和伪目标有相同之处. 需要注意, 在使用空命令的目标时, 如果需要实现一个不是实际文件的目标, 我们只是需要通过使用这个目标来完成对它所依赖的文件的重建动作. 首先应该想到伪目标而不是空命令目标.

因为一个实际不存在的目标文件的依赖文件, 可能不会被正确重建. 因此对于空命令规则, 最好不要给它指定依赖文件. 避免特殊情况下产生错误的情况.
