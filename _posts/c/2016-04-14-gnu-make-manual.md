---
title: "GNU Make 中文手册 - 读书笔记"
date: 2016-04-14 14:28:04
tags: c
---

## 第二章

### 相关概念名词

`make` 中的概念: `目标`, `依赖`, `命令行`.

依赖和命令行称为目标的规则, make 程序根据规则依赖关系, 决定是否执行规则所定义的命令行的过程称之为规则执行.

<!--more-->

命令行**必须**以 `Tab` 字符开始, 不过并不是所有的以 `Tab` 开始的行都是命令行.

Make 程序把出现在第一条规则之后的所有以 `Tab` 开始的行, 都当做命令行. --> 这句话有点怪

概念: 伪目标(Phony Targets), 指的是没有依赖只有执行动作的目标

默认情况下, make 执行的是**第一个**遇到的目标规则. 这个目标也称为 `终极目标`

`make` 不对提供给他的 Makefile 里面的规则依赖和命令行合法性最检查(因为它也不知道怎么检查), 它只是简单的执行提供给他的规则信息. 在遇到错误时, `make` 会立即退出并报告错误.

### 2.5 指定变量

使用 `name = ` 的语法来定义变量, 使用的时候使用 `$(name)` 来指代变量值. 比如:

```makefile
objects = main.o \
	display.o

edit: $(objects)
	cc -o edit $(objects)

main.o: main.c main.h
	cc -c main.c -o main.o

display.o: display.c display.h app.h
	cc -c display.c -o display.o

clean:
	rm $(objects)
```

### 2.6 自动推导规则

`make` 自带一个默认的规则(即 `隐含规则`), 能够自动使用 `cc -c` 完成对 `.c` 到 `.o` 文件编译. 在 Makefile 中我们只需要提供 `.o` 目标文件名字, `make` 就会自动的寻找合适的依赖文件, 并编译它.

利用隐含规则, 上面 makefile 现在可以更新为:

```diff
--- a/Makefile
+++ b/Makefile
@@ -4,12 +4,9 @@ objects = main.o \
 edit: $(objects)
 	cc -o edit $(objects)

-main.o: main.c main.h
-	cc -c main.c -o main.o
-
-display.o: display.c display.h app.h
-	cc -c display.c -o display.o
+main.o:
+display.o: app.h

 clean:
-	rm $(objects)
+	rm edit $(objects)
```

### 关于伪目标的说明

1. 可以通过 `.PHONY` 特殊目标将 `clean` 目标声明为伪目标. 如此可以避免当磁盘上存在一个名为 `clean` 文件时, 目标 `clean` 所在规则的命令无法执行
2. 在命令行之前使用 `-` 可以忽略命令 `rm` 的执行错误.

```diff
--- a/Makefile
+++ b/Makefile
@@ -1,6 +1,8 @@
 objects = main.o \
 	display.o

+.PHONY: clean
+
 edit: $(objects)
 	cc -o edit $(objects)

@@ -8,5 +10,4 @@ main.o:
 display.o: app.h

 clean:
-	rm edit $(objects)
+	-rm edit $(objects)
```

## 第三章

### 相关概念名词

`显式规则`, `隐含规则`, `变量定义`, `指示符`, `注释`

- 显式规则: 描述了在何种情况下如何更新一个或者多个被称为目标的文件
- 隐含规则: make 根据一类目标文件(典型的是根据文件名的后缀)而自动推导出来的规则
- 变量定义: 使用一个字符或字符串代表一段文本串, 当定义了一个变量以后, Makefile 后续在需要使用此文本串的地方, 通过引用这个变量来实现对文本串的使用
- Makefile 指示符: 指示符指明在 make 程序读取 makefile 文件过程中所要执行的一个动作. 其中包括:
  – 读取一个文件, 读取给定文件名的文件, 将其内容作为 makefile 文件的一部分.
  – 决定(通常是根据一个变量的得值)处理或者忽略 Makefile 中的某一特定部分
  – 定义一个多行变量
- 注释: Makefile 中 `#` 字符后的内容被作为是注释内容(和 shell 脚本一样)处理. 如果此行的第一个非空字符为`#`, 那么此行为注释行. 注释行的结尾如果存在反斜线(`\`), 那么下一行也被作为注释行.

```diff
--- a/Makefile
+++ b/Makefile
@@ -6,6 +6,9 @@ objects = main.o \
 edit: $(objects)
 	cc -o edit $(objects)

+# This is a comment \
+comment too
+
 main.o:
 display.o: app.h
```

> 奇技淫巧: 利用 make 的隐含规则, 构建 Makefile 里面不存在的目标: `make foo.o`, 将会执行 `cc -c -o foo.o foo.c`

#### 自动变量

- `$^` 代表所有通过目录搜索得到的依赖文件的完整路径名(目录 + 一般文件名)列表
- `$@` 代表规则的目标
- `$<` 代表规则中通过目录搜索得到的依赖文件列表的第一个依赖文件
- `$*` 代表在静态模式规则中匹配到的目标模式的 `茎`
- `$?` 表示依赖文件列表中被改变过的所有文件
- 变量 `CFLAGS` 是编译 `.c` 文件时 gcc 的编译选项, 可以在 Makefile 中给它指定明确的值, 也可以使用隐含的定义值

#### 等于号和他的变种

详细可以参考文章[https://www.cnblogs.com/wanqieddy/archive/2011/09/21/2184257.html](https://www.cnblogs.com/wanqieddy/archive/2011/09/21/2184257.html):

- `=` 是最基本的赋值, make 在整个 makefile 展开之后, 再来决定变量值
- `:=` 是覆盖之前的值, make 在展开过程中, 就决定了变量值
- `?=` 是如果没有被赋值过就赋予等号后面的值
- `+=` 是添加等号后面的值

### 3.3 包含其它 makefile 文件

> 概念: `include` 指示符

在 Makefile 里面可以使用 `include` 包含其他的 Makefile 文件. `make` 在遇到 `include` 语句时, 会暂停当前 Makefile 的读取, 转而去读取被包含的那个(或者多个)文件.

```diff
--- a/Makefile
+++ b/Makefile
@@ -6,6 +6,8 @@ objects = main.o \
 edit: $(objects)
 	cc -o edit $(objects)

+include Makefile.include
+
 # This is a comment \
 comment too

--- /dev/null
+++ b/Makefile.include
@@ -0,0 +1,2 @@
+inc:
+	@echo Hello Include
```

执行 `make inc` 可以看到, `inc` 目标确实被包含了进来.

### 重要的变量(环境变量/内置变量)

`MAKEFILES`: `make` 在正式读取 Makefile 文件之前, 先读取此变量指定的文件的内容, 多用于 `make` 递归调用过程中的通讯

`MAKEFILES_LIST`: `make` 程序在读取多个 makefile 文件时, 包括由环境变量 `MAKEFILES` 指定/命令行指定/当前工作下的默认的以及使用指示符 `include` 指定包含的, 在对这些文件进行解析执行之前 make 读取的文件名将会被自动依次追加到变量 `MAKEFILE_LIST` 的定义域中.

`.VARIABLES` 变量无法通过任何途径赋值, 它由 `make` 自动维护, 他被展开之后是此引用点之前 makefile 文件中所定义的所有全局变量列表. 包括 `空变量(未赋值的变量)` 和 `make 的内嵌变量`, 但不包含目标指定的变量, 目标指定变量值在特定目标的上下文有效.

### 4.3 依赖的类型

`常规依赖` 和 `order-only` 依赖.

```makefile
TARGETS: NORMAL-PREREQUISITES | ORDER-ONLY-PREREQUISITES
```

`order-only` 依赖的特性是, 当 `order-only` 中的依赖文件发生变化的时候, `TARGETS` 不会重新构建.

### 4.4 文件名中使用通配符

Maekfile 中表示文件名时可使用通配符, 可使用的通配符有 `*`, `?`, `[...]`, 在 Makefile 中通配符的用法和含义和 Bash 中完全相同. 不过 Makefile 中这些统配符并不是可以用在任何地方, Makefile 中统配符可以出现在以下两种场合:

1. 可以用在规则的目标, 依赖中. make 在读取 Makefile 时会自动对其进行匹配处理(通配符展开)
2. 可出现在规则的命令中, 通配符的通配处理是在 shell 在执行此命令时完成的

除这两种情况之外的其它上下文中不能直接使用通配符, 而是需要通过函数 `wildcard` 来实现

> 注意: 变量定义中使用的通配符不会被统配处理, 如果需要在变量里面使用通配符, 需要使用 `wildcard` 函数.

```diff
--- a/Makefile
+++ b/Makefile
@@ -1,11 +1,10 @@
-objects = main.o \
-	display.o
+objects := $(patsubst %.c, %.o, $(wildcard *.c))

 .PHONY: clean

 edit: $(objects)
 	cc -o edit $(objects)
-	echo "${.VARIABLES}"
+	@echo *.c

 include Makefile.include

@@ -16,5 +15,7 @@ comment too
 main.o:
 display.o: app.h

+
+
 clean:
 	-rm edit $(objects)
```

### 4.5 目录搜寻

#### 4.5.1 一般搜索(变量 `VPATH`)

通过变量 `VPATH` 可以指定依赖文件的搜索路径, 当规则的依赖文件在当前目录不存在时, make 会在此变量所指定的目录下去寻找这些依赖文件, 其实 `VPATH` 变量所指定的是 Makefile 中所有文件的搜索路径, 包括了规则的依赖文件和目标文件.

定义变量 `VPATH` 时, 使用空格 ` ` 或者冒号 `:` 将多个需要搜索的目录分开. make 搜索目录的顺序是按照变量 `VPATH` 定义中的目录顺序进行的(当前目录永远是第一搜索目录).

```
VPATH = src:../headers
```

比如我们给 `display.[ch]` 创建一个叫做 display 的目录, 把文件移动进去, 使用 `VPATH` 指定这个搜索目录, make 依然能正常的编译得到可执行文件.

```makefile
objects := main.o display.o kbd.o

VPATH = display

.PHONY: clean

edit: $(objects)
	cc -o edit $(objects)
	@echo *.c

main.o: display.h kbd.h app.h
display.o: app.h
kbd.o: app.h

clean:
	-rm edit $(objects)
```

#### 4.5.2 选择性搜索(关键字 `vpath`)

相比 `VPATH` 那么粗粒度的目录指定方式, `vpath` 可以为不同的文件类型指定不同的搜索目录, 使用方法如下:

1. `vpath PATTERN DIRECTORIES` 为所有符合模式 `PATTERN` 的文件指定搜索目录 `DIRECTORIES`, 多个目录使用空格或者冒号分开, 类似上一小节的 `VPATH` 变量
2. `vpath PATTERN` 清除之前为符合模式 `PATTERN` 的文件设置的搜索路径
3. `vpath` 清除所有已被设置的文件搜索路径

比如:

```makefile
vpath %.h ../headers
```

这个例子, 告诉 make `*.h` 文件需要去 `../headers` 文件夹里面寻找.

#### 4.5.6 库文件和搜索目录

Makefile 中程序链接的静态库/共享库同样也可以通过搜索目录得到. 这一特性需要我们在规则的依赖时指定一个类似 `-lNAME` 的依赖文件名, 比如:

```makefile
foo: foo.c -lcurses
	cc $^ -o $@
```

遇到这种依赖文件的时候 make 将:

1. 在执行规则时会在当前目录下搜索一个名字为 `libNAME.so` 的文件
2. 如果当前工作目录下不存在这样一个文件, 则 make 会继续使用 `VPATH` 或者 `vpath` 指定的搜索目录搜索
3. 还是不存在, make 将搜索系统库文件存在的默认目录, 顺序是: `/lib`, `/usr/lib`, `PREFIX/lib`(在 Linux 系统中为 `/usr/local/lib`, 其他的系统可能不同).

如果 `libNAME.so` 通过以上的途径最后还是没有找到的话, 那么 make 将会按照以上的搜索顺序查找名字为 `libNAME.a` 的文件.

在规则的依赖列表中如果出现 `-lNAME` 格式的依赖时, 表示需要搜索的依赖文件名为 `libNAME.so` 和 `libNAME.a`, 这是由变量 `.LIBPATTERNS` 指定的.

`.LIBPATTERNS` 的值一般是多个包含模式字符 `%` 的一个不包含空格的字符串(字), 多个字之间使用空格分开. 在规则中出现 `-lNAME` 格式的依赖时, 首先使用这里的 `NAME` 代替变量 `.LIBPATTERNS` 的第一个字的模式字符而得到第一个库文件名, 根据这个库文件名在搜索目录下查找, 如果能够找到就使用这个文件, 否则使用 `NAME` 代替第二个字的模式字符, 进行同样的查找.

默认情况下 `.LIBPATTERNS` 的值为 `lib%.so lib%.a`. 这也是默认情况下在规则存在 `-lNAME` 格式的依赖时, 链接生成目标时使用 `libNAME.so` 和 `libNAME.a` 的原因.

变量 `.LIBPATTERNS` 就是告诉链接器在执行链接过程中对于出现 `-LNAME` 的文件如何展开, 当然我们也可以将此变量置空, 取消链接器对 `-lNAME` 格式的展开.

### 4.6 伪目标

将一个目标声明为伪目标的方法是将它作为特殊目标 `.PHONY` 的依赖.

使用伪目标有两点原因:

1. 避免在我们的 Makefile 中定义的只执行命令的目标(此目标的目的为了执行执行一些列命令, 而不需要创建这个目标)和工作目录下的实际文件出现名字冲突
2. 提高执行 make 时的效率.

在 make 的并行和递归执行过程中, 此情况下一般会存在一个变量, 定义为所有需要 make 的子目录, 对多个目录进行 make 的实现方式可以是*在一个规则的命令行中使用 shell 循环来完成*, 比如像下面这样:

```makefile
SUBDIRS = foo bar baz
subdirs:
	for dir in $(SUBDIRS); do \
		$(MAKE) -C $$dir; \
	done
```

这种方式是利用 shell 的能力, 逐个处理 subdirs. 如果把这个工作交给 make 处理, 则可以充分利用 make 的并行特性:

```makefile
SUBDIRS = foo bar baz
.PHANY: subdirs $(SUBDIRS)

subdirs: $(SUBDIRS)
$(SUBDIRS):
    $(MAKE) -C $@
foo: bar
```

说明: 通常在清除文件的伪目标所定义的命令中 `rm` 使用选项 `–f(–-force)` 来防止在缺少删除文件时出错并退出, 使 `make clean` 过程失败. 也可以在 `rm` 之前加上 `-` 来防止 `rm` 错误退出, 这种方式时 make 会提示错误信息但不会退出. 另外 make 存在一个内嵌隐含变量 `RM`, 它被定义为: `RM = rm –f`. 因此 在书写 `clean` 规则的命令行时可以使用变量 `$(RM)` 来代替 `rm`.

### 4.7 强制目标(没有命令或依赖的规则)

如果一个规则没有命令或者依赖, 并且它的目标不是一个存在的文件名, 那么在执行此规则时, 目标总会被认为是最新的. 就是说这个规则一旦被执行, make 就认为它的目标已经被更新过. 这 样的目标在作为一个规则的依赖时, 因为依赖总被认为被更新过, 因此作为依赖所在的规则中定义的命令总会被执行.

```makefile
clean: FORCE
    rm $(objects)

FORCE:
```

### 4.8 空目标文件

空目标文件是伪目标的一个变种, 此目标所在规则执行的目的和伪目标相同: 通过 make 命 令行指定将其作为终极目标来执行此规则所定义的命令.

和伪目标不同的是, 这个目标可以是一个存在的文件, 但文件的具体内容我们并不关心, 通常此文件是一个空文件. 空目标文件只是用来记录上一次执行此规则命令的时间. 在这样的规则中, 命令部分都会使用 `touch` 在完成所有命令之后来更新目标文件的时间戳, 记录此规则命令的最后执行时间. make 时通过命令行将此目标作为终极目标, 当前目录下如果不存在这个文件, `touch` 会在第一次执行时创建一个空的文件(命名为空目标文件名).

通常, 一个空目标文件应该存在一个或者多个依赖文件, 将这个目标作为终极目标, 在它所依赖的文件比它新时, 此目标所在规则的命令行将被执行.

```makefile
print: foo.c bar.c
    lpr -p $?
    touch print
```

### 4.9 Makefile 的特殊目标

- `.PHONY`: 目标 `.PHONY` 的所有的依赖被作为伪目标
- `.DEFAULT`: 目标 `.DEFAULT` 所在规则定义的命令, 被用在重建那些没有具体规则的目标(明确规则和隐含规则). 就是说一个文件作为某个规则的依赖, 但却不是另外一个规则的目标 时, Make 程序无法找到重建此文件的规则, 此种情况时就执行 `.DEFAULT` 所指定的命令
- `.PRECIOUS`: 目标 `.PRECIOUS` 的所有依赖文件在 make 过程中会被特殊处理: 当命令在执行过程中被中断时, make 不会删除它们. 而且如果目标的依赖文件是中间过程文件, 同样这些文件不会被删除. 这一点目标 `.PRECIOUS` 和目标 `.SECONDAY` 实现的功能相同. 另外, 目标 `.PRECIOUS` 的依赖文件也可以是一个模式, 例如 `%.o`, 这样可以保留有规则创建的中间过程文件.
- `.INTERMEDIATE`: 目标 `.INTERMEDIATE` 的依赖文件在 make 时被作为中间过程文件对待. 没有任何依赖文件的目标 `.INTERMEDIATE` 没有意义
- `.SECONDARY`: 目标 `.SECONDARY` 的依赖文件被作为中间过程文件对待, 但这些文件不会被自动删除.
- `.DELETE_ON_ERROR`: 如果在 Makefile 中存在特殊目标 `.DELETE_ON_ERROR`, make 在执行过程中, 如果规则的命令执行错误, 将删除已经被修改的目标文件.
- `.IGNORE`: 如果给目标 `.IGNORE` 指定依赖文件, 则忽略创建这个文件所执行命令的错误. 给此目标指定命令是没有意义的. 当此目标没有依赖文件时, 将忽略所有命令执行的错误.
- `.LOW_RESOLUTION_TIME`: 目标 `.LOW_RESOLUTION_TIME` 的依赖文件被 make 认为是低分辨率时间戳文件. 给目标 `.LOW_RESOLUTION_TIME` 指定命令是没有意义的. 通常文件的时间辍都是高分辨率的, make 在处理依赖关系时, 对规则目标-依赖文件的高分辨率的时间戳进行比较, 判断目标是否过期. 但是在系统中并没有提供一个修改文件高分辨率时间辍的机制(方式), 因此类似 `cp -p` 这样的命令在根据源文件创建目的文件时, 所产生的目的文件的高分辨率时间辍的细粒度部分被丢弃(来源于源文件). 这样可能会造成目的文件的时间戳和源文件的相等甚至不及源文件新. 处理此类命令创建的文件时, 需要将命令创建的文件作为目标 `.LOW_RESOLUTION_TIME` 的依赖, 声明这个文件是一个低分辨率时间辍的文件
- `.SILENT`: 出现在目标 `.SILENT` 的依赖列表中的文件, make 在创建这些文件时, 不打印出重建此文件所执行的命令. 没有任何依赖文件的目标 `.SILENT` 告诉 make 在执行过程中不打印任何执行的命令
- `.EXPORT_ALL_VARIABLES`: 此目标应该作为一个简单的没有依赖的目标, 它的功能含义是将之后所有的变量传递给子 make 进程
- `.NOTPARALLEL`: Makefile 中, 如果出现目标 `.NOPARALLEL`, 则所有命令按照串行方式执行, 即使存在 make 的命令行参数 `-j`. 但在递归调用的子 make 进程中, 命令可以并行执行.

所有定义的隐含规则后缀作为目标出现时, 都被视为一个特殊目标, 两个后缀串联起来也是如此, 例如 `.c.o`. 这样的目标被称为**后缀规则的目标**, 这种定义方式是已经过时的定义隐含规则的方法(目前, 这种方式还被用在很多地方). 原则上, 如果将其分为两个部分, 并将它们加到后缀列表中, 任何目标都可采用这种方式来表示. 实际中, 后缀通常以 `.` 开始, 因此, 以上的这些特别目标同样是以 `.` 开始

### 4.10 多目标

一个规则中可以有多个目标, 规则所定义的命令对所有的目标有效. 一个具有多目标的规则相当于多个规则, 规则的命令对不同的目标的执行效果不同, 因为在规则的命令中可能使用了自动环变量`$@`. 多目标规则意味着所有的目标具有相同的依赖文件. 多目标通常用在以下两种情况:

1. 仅需要一个描述依赖关系的规则, 不需要在规则中定义命令. 例如 `kbd.o command.o files.o: command.h` 这个规则实现了同时给三个目标文件指定一个依赖文件.
2. 对于多个具有类似重建命令的目标. 重建这些目标的命令并不需要是完全相同, 因为可以在命令行中使用自动环变量 `$@` 来引用具体的目标, 完成对它的重建.

虽然在多目标的规则中, 可以根据不同的目标使用不同的命令(在命令行中使用自动化变量 `$@`). 但是, 多目标的规则并不能做到根据目标文件自动改变依赖文件(像上边例子中使用自动化变量 `$@` 改变规则的命令一样). 需要实现这个目的是, 要用到 make 的静态模式.

### 4.11 多规则目标

Makefile 中, 一个文件可以作为多个规则的目标(多个规则中只能有一个规则定义命令). 这种情况时, 以这个文件为目标的规则的所有依赖文件将会被合并成此目标一个依赖文件列表, 当其中任何一个依赖文件比目标更新(比较目标文件和依赖文件的时间戳)时, make 将会执行特定的命令来重建这个目标.

对于一个多规则的目标, 重建此目标的命令只能出现在一个规则中(可以是多条命令). 如果多个规则同时给出重建此目标的命令, make 将使用最后一个规则中所定义的命令, 同时提示错误信息某些情况, 需要对相同的目标使用不同的规则中所定义的命令, 我们需要 `双冒号` 规则来实现.

一个仅仅描述依赖关系的述规则可用来给出一个或做多个目标文件的依赖文件. 例如, Makefile 中通常存在一个变量, 就像以前我们提到的 `objects` , 它定义为所有的需要编译生成的 `.o` 文件的列表. 当这些 `.o` 文件在其源文件所包含的头文件 `config.h` 发生变化之后能够自动的被重建, 我们可以使用多目标的方式来书写 Makefile:

```makefile
objects = foo.o bar.o
foo.o : defs.h
bar.o : defs.h test.h
$(objects) : config.h
```

这样做的好处是: 我们可以在源文件增加或者删除了包含的头文件以后不用修改已经存在的 Makefile 的规则, 只需要增加或者删除某一个.o 文件依赖的头文件. 这种方式很简单也很方便. 对于一个大的工程来说, 这样做的好处是显而易见的. 在一个大的工程中, 对于一个单独目录下的 `.o` 文件的依赖规则建议使用此方式. 规则中头文件的依赖描述规则也可以使用 gcc 自动产生.

另外, 我们也可以通过一个变量来增加目标的依赖文件, 使用 make 的命令行来指定某一个目 标的依赖头文件, 例如:

```makefile
extradeps=
$(objects) : $(extradeps)
```

它的意思是: 如果我们执行 `make extradeps=foo.h` 那么 `foo.h` 将作为所有的 `.o` 文件的依赖文件. 当然我们只执行 `make` 的话, 就没有指定任何文件作为 `.o` 文件的依赖文件.

在多规则的目标中, 如果目标的任何一个规则没有定义重建此目标的命令, make 将会寻找一个合适的隐含规则来重建此目标. 关于隐含规则可参考第十章 make 的隐含规则.

### 4.12 静态模式

静态模式规则是这样一个规则: 规则存在多个目标, 并且不同的目标可以根据目标文件的名字来自动构造出依赖文件. 静态模式规则比多目标规则更通用, 它不需要多个目标具有相同的依赖, 但是静态模式规则中的依赖文件必须是相类似的而不是完全相同的.

#### 4.12.1 静态模式规则的语法

首先, 我们来看一下静态模式规则的基本语法:

```makefile
TARGET ... : TAGET-PATTERN : PREREQ-PATTERNS ...
    COMMANDS
    ...
```

`TAGETS` 列出了此规则的一系列目标文件, 像普通规则的目标一样可以包含通配符. `TAGET-PATTERN` 和 `PREREQ-PATTERNS` 说明了如何为每一个目标文件生成依赖文件. 从目标模式(`TAGET-PATTERN`)的目标名字中抽取一部分字符串(称为 `茎` ). 使用 `茎` 替代依赖模式(`PREREQ-PATTERNS`)中的相应部分来产生对应目标的依赖文件. 下边详细介绍这一替代的过程.

首先在目标模式和依赖模式中, 一般需要包含模式字符 `%`. 在目标模式中 `%` 可以匹配目标文件的任何部分, 模式字符 `%` 匹配的部分就是 `茎`. 目标文件和目标模式的其余部分必须精确的匹配. 比如: 目标 `foo.o` 符合模式 `%.o`, 其 `茎` 为 `foo`. 而目标 `foo.c` 和 `foo.out` 就不符合此目标模式.

每一个目标的依赖文件是使用此目标的 `茎` 代替依赖模式(`PREREQ-PATTERNS`)中的模式字符 `%` 而得到. 例如: 上边的例子中依赖模式(`PREREQ-PATTERNS`)为 `%.c`, 那么使用 `茎` `foo` 替代依赖模式中的 `%` 得到的依赖文件就是 `foo.c`.

需要明确的一点是: 在模式规则的依赖列表中使用不包含模式字符 `%` 也是合法的. 代表这个文件是所有目标的依赖文件.

我们来看一个例子, 它根据相应的.c 文件来编译生成 `foo.o` 和 `bar.o` 文件:

```makefile
objects = foo.o bar.o

all: $(objects)

$(objects): %.o: %.c
	$(CC) -c $(CFLAGS) $< -o $@
```

例子中, 规则描述了所有的 `.o` 文件的依赖文件为对应的 `.c` 文件, 对于目标 `foo.o`, 取其茎 `foo` 替代对应的依赖模式 `%.c` 中的模式字符 `%` 之后可得到目标的依赖文件 `foo.c`. 这就是目标 `foo.o` 的依赖关系 `foo.o: foo.c`, 规则的命令行描述了如何完成由 `foo.c` 编译生成目标 `foo.o`. 命令行中 `$<` 和 `$@` 是自动化变量, `$<` 表示规则中的第一个依赖文件, `$@` 表示规则中的目标文件. 上边的这个规则描述了以下两个具体的规则:

```makefile
foo.o: foo.c
	$(CC) -c $(CFLAGS) foo.c -o foo.o

bar.o: bar.c
	$(CC) -c $(CFLAGS) bar.c -o bar.o
```

在使用静态模式规则时, 指定的目标必须和目标模式相匹配, 否则执行 make 时将会得到一个错误提示. 比如上面 `$(objects): %.o: %.c` 如果写成了 `$(objects): %.x: %.c`, 就会因为没有办法匹配合适的依赖文件导致报错.

如果存在一个文件列表, 其中一部分符合某一种模式而另外一部分符合另外一种模式, 这种情况下我们可以使用 `filter` 函数来对这个文件列表进行分类, 在分类之后对确定的某一类使用模式规则. 例如:

```makefile
files = foo.elc bar.o lose.o

$(filter %.o, $(files)): %.o: %.c
	$(CC) -c $(CFLAGS) $< -o $@

$(filter %.elc, $(files)): %.elc: %.el
	emacs -f batch-byte-compile $<
```

其中 `$(filter %.o, $(files))` 的结果为 `bar.o lose.o`. `filter` 函数过滤不符合 `%.o` 模式的文件名而返回所有符合此模式的文件列表. 第一条静态模式规则描述了这些目标文件是通过编译对应的 `.c` 源文件来重建的. 同样第二条规则也是使用这种方式.

我们通过另外一个例子来看一下自动环变量 `$*` 在静态模式规则中的使用方法:

```makefile
bigoutput littleoutput : %output : text.g
	generate text.g -$* > $@
```

当执行此规则的命令时, 自动环变量 `$*` 被展开为 `茎` . 在这里就是 `big` 和 `little`.

静态模式规则对一个较大工程的管理非常有用, 它可以对整个工程的同一类文件的重建规则进行一次定义, 而实现对整个工程中此类文件指定相同的重建规则. 比如, 可以用来描述整个工程中所 有的 `.o` 文件的依赖规则和编译命令. 通常的做法是将生成同一类目标的模式定义在一个 `make.rules` 的文件中. 在工程各个模块的 Makefile 中包含此文件.

#### 4.12.2 静态模式和隐含规则

Makefile 中, **静态模式规则**和被定义为**隐含规则的模式规则**是我们经常使用的两种方式. 两者相同的地方都是用目标模式和依赖模式来构建目标的规则中的文件依赖关系, 两者不同的地方是 make 在执行时使用它们的时机.

隐含规则可被用在任何和它相匹配的目标上, 在 Makefile 中没有为这个目标指定具体的规则, 存在规则但规则没有命令行或者这个目标的依赖文件可被搜寻到. 当存在多个隐含规则和目标模式相匹配时, 只执行其中的一个规则. 具体执行哪一个规则取决于定义规则的顺序.

相反的, 静态模式规则只能用在规则中明确指出的那些文件的重建过程中. 不能用在除此之外的任何文件的重建过程中, 并且它对指定的每一个目标来说是唯一的. 如果一个目标存在于两个规 则, 并且这两个规则都定以了命令, make 执行时就会提示错误.

静态模式规则相比隐含模式规则有以下两个优点:

1. 不能根据文件名通过词法分析进行分类的文件, 我们可以明确列出这些文件, 并使用静态模式规则来重建其隐含规则
2. 对于无法确定工作目录内容, 并且不能确定是否此目录下的无关文件会使用错误的隐含规则而导致 make 失败的情况. 当存在多个适合此文件的隐含规则时, 使用哪一个隐含规则取决于其规则的定义顺序. 这种情况下我们使用静态模式规则就可以避免这些不确定因素, 因为静态模式中, 指定的目标文件有明确的规则来描述其依赖关系和重建命令

### 4.13 双冒号规则

双冒号规则就是使用 `::` 代替普通规则的 `:` 得到的规则. 当同一个文件作为多个规则的目标时, 双冒号规则的处理和普通规则的处理过程完全不同(双冒号规则允许在多个规则中为同一个目标指定不同的重建目标的命令).

> **注意**:
>
> Makefile 中, 一个目标**可以**出现在多个规则中, 但是这这些规则必须是同一类型的规则, 要么都是普通规则, 要么都是双冒号规则. 而不允许一个目标同时出现在两种不同类型的规则中

双冒号规则和普通规则的处理的不同点表现在以下几个方面:

1. 双冒号规则中, 当依赖文件比目标更新时规则将会被执行. 对于一个没有依赖而只有命令行的双冒号规则, 当引用此目标时, 规则的命令将会被无条件执行. 而普通规则, 当规则的目标文件存在时, 此规则的命令永远不会被执行(目标文件永远是最新的). **???**
2. 当同一个文件作为多个双冒号规则的目标时, 这些不同的规则会被独立的处理, 而不是像普通规则那样合并所有的依赖到一个目标文件. 这就意味着对这些规则的处理就像多个不同的普通规则一样. 就是说多个双冒号规则中的每一个的依赖文件被改变之后, make 只执行此规则定义的命令, 而其它的以这个文件作为目标的双冒号规则将不会被执行.

我们来看一个例子, 在我们的 Makefile 中包含以下两个规则:

```makefile
Newprog :: foo.c
	$(CC) $(CFLAGS) $< -o $@

Newprog :: bar.c
	$(CC) $(CFLAGS) $< -o $@
```

如果 `foo.c` 文件被修改, 执行 make 以后将根据 `foo.c` 文件重建目标 `Newprog`. 而如果 `bar.c` 被修改那么 `Newprog` 将根据 `bar.c` 被重建. 回想一下, 如果以上两个规则为普通规时出现的情况是什么? (make 将会出错并提示错误信息).

当同一个目标出现在多个双冒号规则中时, 规则的执行顺序和普通规则的执行顺序一样, 按照其在 Makefile 中的书写顺序执行.

GNU make 的双冒号规则给我们提供一种根据依赖的更新情况而执行不同的命令来重建同一目标的机制. 一般这种需要的情况很少, 所以双冒号规则的使用比较罕见. 一般双冒号规则都需要定义命令, 如果一个双冒号规则没有定义命令, 在执行规则时将为其目标自动查找隐含规则.

### 4.14 自动产生依赖

Makefile 中, 有时要书写一些规则描述一个 `.o` 文件和头文件的依赖关系. 例如, 如果在 `main.c` 中使用 `#include defs.h`, 那么我们可能就需要一个像下边那样的规则来描述当头文件 `defs.h` 被修改以后再次执行 make, 目标 `main.o` 应该被重建.

```makefile
main.o: defs.h
```

这样, 对于一个大型工程就需要在 Makefile 中书写很多条类似于这样的规则. 并且, 当在源文件中加入或删除头文件后, 也需要小心地去修改 Makefile. 这是一件非常费力费时并且危险(容易出错误)的工作. 为了避免这个讨厌的问题, 现代的 c 编译器提供了通过查找源文件中的 `#include` 来自动产生这种依赖关系的功能.

Gcc 通过 `-M` 选项来实现此功能, 使用 `-M` 选项 gcc 将自动找寻源文件中包含的头文件, 并生成文件的依赖关系. 例如, 如果 `main.c` 只包含了头文件 `defs.h`, 那么执行下面的命令(使用 `-MM` 选项可以屏蔽 `-M` 里面输出的标准库头文件):

```bash
gcc -M main.c
```

其输出是:

```makefile
main.o : main.c defs.h
```

在使用 gcc 自动产生依赖关系时, 所产生的规则中明确的指明了目标是 `main.o`. 一次在通过 `.c` 文件直接产生可执行文件时, 作为中间过程文件的 `main.o` 在使用完之后将不会被删除.

在旧版本的 make 中, 使用编译器此项功能通常的做法是在 Makefile 中书写一个伪目标 `depend` 的规则来定义自动产生依赖关系文件的命令. 输入 `make depend` 将生成一个称为 `depend` 的文件, 其中包含了所有源文件的依赖规则描述. Makefile 中使用 `include` 指示符包含这个文件.

在新版本的 make 中, 推荐的方式是为每一个源文件产生一个描述其依赖关系的 makefile 文件. 对于一个源文件 `NAME.c`, 对应的这个 makefile 文件为 `NAME.d`. `NAME.d` 中描述了文件 `NAME.o` 所要依赖的所有头文件. 采用这种方式, 只有源文件在修改之后才会重新使用命令生成新的依赖关系描述文件 `NAME.o`.

我们可以使用如下的模式规则来自动生成每一个 `.c` 文件对应的 `.d` 文件(注意看 sed 把 `%.o, %.d` 文件当做规则的依赖):

```makefile
%.d: %.c
	$(CC) -MM $(CFLAGS) $< > $@.$$$$; \
    sed 's,\($*\)\.o[ :]*,\1.o $@ : ,g' < $@.$$$$ > $@; \
    rm -f $@.$$$$
```

> **注意**:
>
> 注意 sed 里面的自动变量 `$*`, `$@`, `$$$$`, 其中 `$$$$` 代表当前 make 进程号(实际上 shell 执行的是 `$$`, makefile 写法转义了)

使用上例的规则就可以建立一个描述目标文件依赖关系的 `.d` 文件. 我们可以在 Makefile 中使用 `include` 指示符将描述将这个文件包含进来. 在执行 make 时, Makefile 所包含的所有 `.d` 文件就会被自动创建或者更新. Makefile 中对当前目录下 `.d` 文件处理可以参考如下:

```makefile
sources = foo.c bar.c
sinclude $(sources:.c=.d)
```

例子中, 变量 `sources` 定义了当前目录下的需要编译的源文件. 变量引用置换 `$(sources: .c=.d)` 的功能是根据变量 `source` 指定的 `.c` 文件自动产生对应的 `.d` 文件, 并在当前 Makefile 文件中包 含这些 `.d` 文件. `.d` 文件和其它的 makefile 文件一样, make 在执行时读取并试图重建它们. 其实这些 `.d` 文件也是一些可被 make 解析的 makefile 文件.

需要注意的是 `include` 指示符的书写顺序, 因为在这些 `.d` 文件中已经存在规则. 当一个 Makefile 使用指示符 include 这些 `.d` 文件时, 应该注意它应该出现在终极目标之后, 以免 `.d` 文件中的规则被是 Makefile 的终极规则. 关于这个前面我们已经有了比较详细的讨论.
